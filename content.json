{"meta":{"title":"谨以此网页，献给一个女孩","subtitle":"李季鸿的博客","description":"如果再相遇，我想我会记得你","author":"Li Jihong","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-09T00:46:30.073Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"A sophomore majoring in computer science and technology, from Hainan University, China 姓名：李季鸿 现居：海南，海口 GitHub: BH04250909 QQ: 2182726049 微信: BH04250909"},{"title":"categories","date":"2022-09-06T12:25:11.000Z","updated":"2022-09-07T06:53:33.414Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-09-06T12:28:42.000Z","updated":"2022-09-07T07:01:59.870Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-06T12:28:12.000Z","updated":"2022-09-07T07:00:07.599Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-07T06:58:32.502Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深度学习之——卷积神经网络","slug":"度学习之——卷积神经网络","date":"2022-09-11T03:40:00.000Z","updated":"2022-09-11T05:59:24.154Z","comments":true,"path":"2022/09/11/度学习之——卷积神经网络/","link":"","permalink":"http://example.com/2022/09/11/%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"","text":"背景 > 是否可能进─步减少训练参数数量? > 办法:提取出图像中的关键信息(轮廓)，再建立MLP模型进行训练 图像卷积运算 对图像矩阵与滤波器矩阵进行对应相乘再求和运算，转化得到新的矩阵,作用:快速定位图像中某些边缘特征 英文: convolution —&gt; CNN A与B的卷积通常表示为: A * B或convolution(A,B) 寻找竖向轮廓 > 结论：包含竖向轮廓的区域非常亮（灰度值高) ###### 寻找竖向轮廓 结论：将图片与轮廓滤波器进行卷积运算,可快速定位固定轮廓特征的位置 > 结论：一个过滤器不够，需要寻找很多过滤器 池化层实现维度缩减 池化:按照一个固定规则对图像矩阵进行处理,将其转换为更低维度的矩阵 最大法池化(Max-pooling)（常用） 保留核心信息的情况下，实现维度缩减 平均法池化(Avg-pooling)（取平均值） 卷积神经网络 把卷积、池化、mlp先后连接在一起，组成卷积神经网络。 ###### 卷积神经网络两大特点 参数共享(parameter sharing): 同一个特征过滤器可用于整张图片 稀疏连接（sparsity of connections): 生成的特征图片每个节点只与原图片中特定节点连接 =&gt; 将特征区域化，减小误差 卷积运算导致的两个问题 图像被压缩，造成信息丢失 边缘信息使用少，容易被忽略 通过padding增加像素的数量，由过滤器尺stride决定 ###### 有效解决方法：图像填充（padding） 通过在图像各边增加像素，使其在进行卷积运算维持原图大小 通过padding增加像素的数量，由过滤器尺stride决定 经典的CNN模型 LeNet-5 AlexNet VGG 参考经典的CNN结构搭建新模型 使用经典的CNN模型结构对图像预处理，再建立MLP模型 LeNet-5 1http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf AlexNet AlexNet论文： 1https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf 输入图像: 227X 227X 3RGB图，3个通道 训练参数:约60,000,000个 特点: 1、适用于识别较为复杂的彩色图，可识别1000种类别 2、结构比LeNet更为复杂，使用Relu作为激活函数 AlexNet的出现使得： 学术界开始相信深度学习技术, 在计算机视觉立用中可以得到很不错的结果。 VGG-16 VGG-16论文： 1https://arxiv.org/pdf/1409.1556.pdf 输入图像:227 X 227X 3 RGB图，3个通道 训练参数:约138,000,000个 特点: 1、所有卷积层tilter 宽和高都是3、步长为1，padding都使用same convolution; 2、所有池化层的 filtey宽和高都是况，步长都是2; 3、相比alexnet，有更多的filter用于提取轮廓信息，具有更高精准性","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://example.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-016 查验身份证","slug":"PTA-天梯赛——L1-016-查验身份证","date":"2022-09-08T13:51:00.000Z","updated":"2022-09-08T13:57:34.874Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-016-查验身份证/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/","excerpt":"PTA-天梯赛——L1-016 查验身份证 一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式： 输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式： 按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。","text":"PTA-天梯赛——L1-016 查验身份证 一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式： 输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式： 按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1： 12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1： 12312010X19890101123411010819671130186637070419881216001X 输入样例2： 1232320124198808240056110108196711301862 输出样例2： 1All passed C++高级解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;map&gt; using namespace std; int main() &#123; map&lt;int, char&gt; m; m.insert(pair&lt;int, char&gt;(0, &#x27;1&#x27;)); m.insert(pair&lt;int, char&gt;(1, &#x27;0&#x27;)); m.insert(pair&lt;int, char&gt;(2, &#x27;X&#x27;)); m.insert(pair&lt;int, char&gt;(3, &#x27;9&#x27;)); m.insert(pair&lt;int, char&gt;(4, &#x27;8&#x27;)); m.insert(pair&lt;int, char&gt;(5, &#x27;7&#x27;)); m.insert(pair&lt;int, char&gt;(6, &#x27;6&#x27;)); m.insert(pair&lt;int, char&gt;(7, &#x27;5&#x27;)); m.insert(pair&lt;int, char&gt;(8, &#x27;4&#x27;)); m.insert(pair&lt;int, char&gt;(9, &#x27;3&#x27;)); m.insert(pair&lt;int, char&gt;(10, &#x27;2&#x27;)); int n; string num[100]; int quan[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;; int count=0; cin&gt;&gt;n; for (int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;num[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; int sum=0; for (int j = 0; j &lt; num[i].size()-1; ++j) &#123; sum+=quan[j]*(num[i][j]-48);//48为字符&#x27;0&#x27;的十进制数 &#125; int Z=sum%11; char M=m[Z]; if (M==num[i][17])&#123; count++; &#125;else&#123; cout&lt;&lt;num[i]&lt;&lt;endl; &#125; &#125; if (count==n)&#123; cout&lt;&lt;&quot;All passed&quot;&lt;&lt;endl; &#125;&#125; C++一般解法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;/*三个变量分别储存权重、对应值、输入的身份证号*/int quanzhong[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;int m[11]=&#123;1,0,10,9,8,7,6,5,4,3,2&#125;; //这里把X转化为10，方便之后的操作 string s;/*用来判断身份证号是否正确*/bool isTrue()&#123; int sum=0; for(int i=0;i&lt;17;i++)&#123; if(s[i]&lt;&#x27;0&#x27; || s[i]&gt;&#x27;9&#x27;)&#123; //先判断输入的值是否合法，如果不合法直接返回false return false; &#125;else&#123; sum += (s[i]-&#x27;0&#x27;)*quanzhong[i]; //用sum来保存每一位与权重相乘的和 &#125; &#125; int temp = (s[17]==&#x27;X&#x27;)?10:(s[17]-&#x27;0&#x27;); //如果最后一位是X的话就转化为10，其他不变 return (m[sum%11] == temp); //返回的值就是校验值与身份证最后一位是否相同 &#125;int main()&#123; int n,flag=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; if(!isTrue())&#123; //如果校验没有通过就把这个身份证输出，并把flag置1 cout&lt;&lt;s&lt;&lt;endl; flag = 1; &#125; &#125; if(flag == 0)&#123; //如果flag为0的话说明所有输入的身份证都通过校验 cout&lt;&lt;&quot;All passed&quot;; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"早知道暑假不留校了","slug":"早知道暑假不留校了","date":"2022-09-08T13:51:00.000Z","updated":"2022-09-08T16:57:12.591Z","comments":true,"path":"2022/09/08/早知道暑假不留校了/","link":"","permalink":"http://example.com/2022/09/08/%E6%97%A9%E7%9F%A5%E9%81%93%E6%9A%91%E5%81%87%E4%B8%8D%E7%95%99%E6%A0%A1%E4%BA%86/","excerpt":"","text":"","categories":[{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-015 跟奥巴马一起画方块","slug":"PTA-天梯赛——L1-015-跟奥巴马一起画方块","date":"2022-09-08T13:16:00.000Z","updated":"2022-09-08T13:23:00.048Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-015-跟奥巴马一起画方块/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/","excerpt":"PTA-天梯赛——L1-015 跟奥巴马一起画方块 美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： 输入在一行中给出正方形边长N（3≤N≤21）和组成正方形边的某种字符C，间隔一个空格。 输出格式： 输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。 输入样例： 110 a 输出样例： 12345aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","text":"PTA-天梯赛——L1-015 跟奥巴马一起画方块 美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： 输入在一行中给出正方形边长N（3≤N≤21）和组成正方形边的某种字符C，间隔一个空格。 输出格式： 输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。 输入样例： 110 a 输出样例： 12345aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 我的解法 简单又容易理解，但一看就很low 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int N; string x; cin&gt;&gt;N; cin&gt;&gt;x; for(int i=0; i&lt;((N-1)/2)+1; i++) &#123; for(int j=0; j&lt;N; j++) &#123; cout&lt;&lt;x[0]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 网上的思路——Java 123456789101112131415161718192021222324252627282930import java.util.Scanner;/** * * @author 李季鸿 * */public class Main &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in);// int n=s.nextInt();// char ch1=s. String str = s.nextLine(); String[] ch=str.split(&quot; &quot;); int n=Integer.parseInt(ch[0]); int b=0; if(n%2==0) &#123; b=n/2; &#125;else &#123; b=(int)(n/2)+1; &#125;// System.out.println(b); for(int i=0;i&lt;b;i++) &#123; for(int j=0;j&lt;n-1;j++) &#123; System.out.print(ch[1]); &#125; System.out.println(ch[1]); &#125; &#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-013 计算阶乘和","slug":"PTA-天梯赛——L1-013-计算阶乘和","date":"2022-09-08T12:28:00.000Z","updated":"2022-09-08T12:40:32.253Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-013-计算阶乘和/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/","excerpt":"PTA-天梯赛——L1-013 计算阶乘和 对于给定的正整数N，需要你计算 S=1!+2!+3!+…+N!。 输入格式： 输入在一行中给出一个不超过10的正整数N。 输出格式： 在一行中输出S的值。 输入样例： 13 输出样例： 19","text":"PTA-天梯赛——L1-013 计算阶乘和 对于给定的正整数N，需要你计算 S=1!+2!+3!+…+N!。 输入格式： 输入在一行中给出一个不超过10的正整数N。 输出格式： 在一行中输出S的值。 输入样例： 13 输出样例： 19 我的解法 简单又容易理解，但一看就很low 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int JieCheng(int x)&#123; if(x&gt;0)&#123; return x*(JieCheng(x-1)); &#125; else&#123; return 1; &#125;&#125;int main() &#123; int N; int SUM = 0; cin&gt;&gt;N; for(int i=N; i&gt;0; i--) &#123; SUM+=JieCheng(i); &#125; cout&lt;&lt;SUM; return 0;&#125; 网上的思路 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int sum=0; for(int i=1;i&lt;=n;i++) &#123; int temp=1; for(int j=1;j&lt;=i;j++) &#123; temp=temp*j; &#125; sum=sum+temp; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"C++ STL库中map的常见操作","slug":"C-STL库中map的常见操作","date":"2022-09-08T06:42:00.000Z","updated":"2022-09-08T08:01:41.931Z","comments":true,"path":"2022/09/08/C-STL库中map的常见操作/","link":"","permalink":"http://example.com/2022/09/08/C-STL%E5%BA%93%E4%B8%ADmap%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了","text":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了 123456789101112//对m进行赋值map&lt;char,int&gt;m;m[&#x27;a&#x27;]=4;m[&#x27;d&#x27;]=1;m[&#x27;c&#x27;]=2;//还是对m进行赋值map&lt;int,int&gt;m;m[1]=6;m[3]=4;m[2]=8;//这些数值均没有任何特殊意义，都是随便赋的值 常用函数 1234567891011121314m.push();m.pop(); //emmmmmm,上面这两个函数在map里面都没有m.clear(); //清空m中的所有元素m.empty(); //判断m是否为空m.begin(); //返回指向map头部的迭代器m.end(); //返回指向map尾部的迭代器m.rbegin(); //返回一个指向map尾部的逆向迭代器m.rend(); //返回一个指向map头部的逆向迭代器m.erase(); //删除指定元素m.inser(); //插入元素m.find(); //查找指定元素m.swap(); //交换两个map中的所有元素（注意：两个map中定义的类型需要完全一致） 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 提前说明： 其实在map内部，已经默认将其中的元素按照中括号中的元素的大小，按照从小到大的顺序排列好了 示例 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;m1; map&lt;char,int&gt;m2; m1[&#x27;q&#x27;] = 1; m1[&#x27;w&#x27;] = 2; m1[&#x27;e&#x27;] = 3; m2[&#x27;a&#x27;] = 4; m2[&#x27;s&#x27;] = 5; m2[&#x27;d&#x27;] = 6; cout&lt;&lt;m1.size()&lt;&lt;endl;//运算结果：3 m1.erase(m1.begin());//删除m1中的第一个元素（指的是中括号中所有元素中最小的，即m1[&#x27;e&#x27;] = 3） map&lt;char,int&gt;::iterator it;//使用迭代器将map中的元素输出 for(it=m1.begin();it!=m1.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;it-&gt;second&lt;&lt;endl;//该语句等价于 cout&lt;&lt;(*it).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*it).second&lt;&lt;endl; //这是map的固定输出格式 &#125; //运算结果：q 1 // w 2 m1.swap(m2);//交换两个map中的所有元素 map&lt;char,int&gt;::reverse_iterator rit; for(rit=m1.rbegin();rit!=m1.rend();rit++)//逆向输出，可以看成从大到小输出 &#123; cout&lt;&lt;(*rit).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*rit).second&lt;&lt;endl; &#125; //运算结果：s 5 // d 5 // a 4return 0;&#125; 下面是整个代码的运算结果：","categories":[{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-011 A-B","slug":"PTA-天梯赛——L1-011-A-B","date":"2022-09-07T13:40:00.000Z","updated":"2022-09-08T00:09:27.887Z","comments":true,"path":"2022/09/07/PTA-天梯赛——L1-011-A-B/","link":"","permalink":"http://example.com/2022/09/07/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-011-A-B/","excerpt":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm!","text":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm! AC【map】 简单又容易理解，但是我不会想到的啊！！！ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); map&lt;char,int&gt; m; for(int i=0; i&lt;b.length(); i++) &#123; m[b[i]]=1; &#125; for(int i=0; i&lt;a.length(); i++) &#123; if(m[a[i]]!=1) &#123; cout&lt;&lt;a[i]; &#125; &#125; return 0;&#125; 【set】 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; s; for(int i=0; i&lt;s2.length(); i++) &#123; s.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; if(s.find(s1[i])==s.end()) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 普通方法1 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b,c=&quot;&quot;; getline(cin,a); getline(cin,b); for(int i=0; i&lt;a.length(); i++) &#123; bool f=0; for(int j=0; j&lt;b.length(); j++) &#123; if(a[i]==b[j]) f=1; &#125; if(f==0) c=c+a[i]; &#125; cout&lt;&lt;c; return 0;&#125; 普通方法2 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); int len=a.length(); for(int i=0; i&lt;b.length(); i++) &#123; char s=b[i]; for(int j=0; j&lt;len; j++) &#123; if(s==a[j]) &#123; for(int k=j; k&lt;len-1; k++) &#123; a[k]=a[k+1]; &#125; len--; j--;//这里要-- 就是排除连着两个一样的字符 &#125; &#125; &#125; for(int i=0; i&lt;len; i++) cout&lt;&lt;a[i]; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"LeetCode刷题","slug":"LeetCode刷题","date":"2022-09-07T13:19:11.958Z","updated":"2022-09-07T06:52:25.850Z","comments":true,"path":"2022/09/07/LeetCode刷题/","link":"","permalink":"http://example.com/2022/09/07/LeetCode%E5%88%B7%E9%A2%98/","excerpt":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;;","text":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 12345678910111213141516171819202122232425class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); int n = intervals.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return n - Arrays.stream(dp).max().getAsInt(); &#125;&#125; 方法2.贪心 思路：intervals按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多，intervals的长度减去最多的不重复的区间 就是最少删除区间的个数 复杂度：时间复杂度O(nlogn)，数组排序O(nlogn)，循环一次数组O(n)。空间复杂度O(logn)，排序需要的栈空间 javascript 123456789101112131415161718192021var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; //按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多 intervals.sort((a, b) =&gt; a[1] - b[1]); const n = intervals.length; let right = intervals[0][1]; //right初始化为第一个区间的右边界 let ans = 1; //最多的不重合区间的个数 for (let i = 1; i &lt; n; ++i) &#123; //循环区间数组 if (intervals[i][0] &gt;= right) &#123; //当区间的左边界大于上一个区间的右边界的时候 说明是一对不重合区间 ++ans; //ans加1 right = intervals[i][1]; //更新right &#125; &#125; return n - ans; //intervals的长度减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 123456789101112131415161718192021222324class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[1] - interval2[1]; &#125; &#125;); int n = intervals.length; int right = intervals[0][1]; int ans = 1; for (int i = 1; i &lt; n; ++i) &#123; if (intervals[i][0] &gt;= right) &#123; ++ans; right = intervals[i][1]; &#125; &#125; return n - ans; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}],"author":"Li Jihong"},{"title":"Hello World","slug":"hello-world","date":"2022-09-07T13:19:11.957Z","updated":"2022-09-08T02:09:05.447Z","comments":true,"path":"2022/09/07/hello-world/","link":"","permalink":"http://example.com/2022/09/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"前端笔记","slug":"前端笔记","date":"2022-09-06T04:00:00.000Z","updated":"2022-09-08T02:08:44.047Z","comments":true,"path":"2022/09/06/前端笔记/","link":"","permalink":"http://example.com/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","excerpt":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt;","text":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 表单全选: 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script&gt; var j_caAll = document.getElementById(&#x27;j_caAll&#x27;); //j_caAll是全局选项 var j_tbs = document.getElementById(&#x27;j_tbs&#x27;).getElementsByTagName(&#x27;input&#x27;); //下面所有的复选框 //注册事件 j_caAll.onclick = function()&#123; //this.checked 它可以得到当前复选框的选中状态，如果是true就是选中，如果是false就是未选中 for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].checked = this.checked; &#125; &#125; for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].onclick = function()&#123; var flag = true; //控制全选按钮是否选中 //每次点击下面的复选框都要检查4个小按钮是否被选中 for(var i =0; i &lt; j_tbs.length; i++)&#123; if(!j_tbs[i].checked)&#123;//有一个按钮没有被选中 flag = false; break; //退出for循环，这样可以提高只要效率，因为只要有一个没被选中，就无需循环 &#125; &#125; j_caAll.checked = flag; &#125; &#125; &lt;/script&gt;&lt;/body&gt; Tab栏切换: 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; var tab_list = document.querySelector(&#x27;.tab_list&#x27;); var lis = tab_list.querySelectorAll(&#x27;li&#x27;); var items = document.querySelectorAll(&#x27;.item&#x27;); //for循环绑定点击事件 for(var i = 0; i&lt; lis.length; i++)&#123; //开始给5个小li 设置索引号 lis[i].setAttribute(&#x27;index&#x27;, i); lis[i].onclick = function()&#123; //1.上的模块选项卡，点击某一个，当前这个底色会是红色，其余不变（排他思想）修改类名的方式 //获取元素 //干掉所有人 其余的li清除class 这个类 for(var i =0 ;i &lt; lis.length; i++)&#123; lis[i].className = &#x27;&#x27;; &#125; //留下我自己 this.className = &#x27;current&#x27;; //2.下面的显示内容模块 var index = this.getAttribute(&#x27;index&#x27;); console.log(index); //干掉所有人 让其余的item 这些div隐藏 for(var i = 0; i &lt; items.length; i++)&#123; items[i].style.display = &#x27;none&#x27;; &#125; //留下我自己 让对应的item 显示出来 items[index].style.display = &#x27;block&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 下拉菜单: 1234567891011121314&lt;script&gt; //1. 获取元素 var nav = document.querySelector(&#x27;.nav&#x27;); var lis = nav.children; //得到四个小li //2. 循环注册事件 for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].onmouseover = function()&#123; this.children[1].style.display = &#x27;block&#x27;; &#125; lis[i].onmouseout = function()&#123; this.children[1].style.display = &#x27;none&#x27;; &#125; &#125; &lt;/script&gt; 简单留言板: 12345678910111213141516171819202122&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value; //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); &#125; &#125; &lt;/script&gt; 删除留言: 123456789101112131415161718192021222324252627282930&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); //(3)删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelector(&#x27;a&#x27;); for(var i=0; i&lt; as.length;i++)&#123; as[i].onclick = function()&#123; //node.removeChild(child); 删除的是li当前所在的li this.parentNode; ul.removeChild(this.parentNode); &#125; &#125; &#125; &#125; &lt;/script&gt; 动态生成表格： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- * @Author: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @Date: 2022-08-17 12:40:22 * @LastEditors: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @LastEditTime: 2022-08-17 14:20:42 * @FilePath: \\JS\\动态生成表格.html * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table &#123; width: 500px; margin: 100px auto; border-collapse: collapse; text-align: center; &#125; td, th &#123; border: 1px solid #333; &#125; thead tr &#123; height: 40px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspacing=&quot;&#x27;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //1.先去准备好学生的数据 var datas =[ &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;javascript&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;C++&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;java&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;linux&#x27;, score:100 &#125;, ]; //2. 往tbody里面创建行：有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector(&#x27;tbody&#x27;); for(var i = 0; i &lt; datas.length; i++)&#123;//外面的for循环管是行 tr //1.创建 tr 行 var tr = document.createElement(&#x27;tr&#x27;); tbody.appendChild(tr); //2.行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数 for循环遍历对象 for(var k in datas[i])&#123; //里卖弄的for循环管的是列 td //创建单元格 var td = document.createElement(&#x27;td&#x27;); //吧对象里面的属性值 datas[i][k] 给td // console.log(datas[i][k]); td.innerHTML = datas[i][k]; tr.appendChild(td); &#125; //3.创建有删除2个字的单元格 var td = document.createElement(&#x27;td&#x27;); td.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 tr.appendChild(td); &#125; //4. 删除操作开始 var as = document.querySelectorAll(&#x27;a&#x27;); for(var i = 0; i &lt; as.length; i++)&#123; as[i].onclick = function()&#123; //点击a 删除当前a所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[],"author":"Li_Jihong"}],"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://example.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"},{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"},{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]}