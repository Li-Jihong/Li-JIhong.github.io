{"meta":{"title":"谨以此网页，献给一个女孩","subtitle":"李季鸿的博客","description":"如果再相遇，我想我会记得你","author":"Li Jihong","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-09T00:46:30.073Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"A sophomore majoring in computer science and technology, from Hainan University, China 姓名：李季鸿 现居：海南，海口 GitHub: BH04250909 QQ: 2182726049 微信: BH04250909"},{"title":"categories","date":"2022-09-06T12:25:11.000Z","updated":"2022-09-07T06:53:33.414Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"photos","date":"2022-09-06T12:28:42.000Z","updated":"2022-09-07T07:01:59.870Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-06T12:26:50.000Z","updated":"2022-09-07T06:58:32.502Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-30T18:16:49.903Z","updated":"2022-10-30T18:16:49.888Z","comments":true,"path":"images/操作.html","permalink":"http://example.com/images/%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"考虑到加入我们的代码库以后可能会有源源不断的人加入，so，鄙人打算写一个详细的操作手册告诉后人如何操作（在此不得不吐槽hlh同学，我诚心邀请他和我一起编写此手册，他居然因为懒直接一口拒绝了我。。） 1.安装git https://git-scm.com 这是git的官网 进入后点击Downloads，下载下面的这个版本： 然后就是安装，按理说没什么特别需要注意的，一直点击next就行，特别提醒，最好将安装位置放到D盘，并且给文件夹命个简约的名（如果你C盘没有分盘，那当我没说）。 怎么检验是否安装成功了呢？ win+R输入cmd，在这里输入git --version，出现 git GUI 和 git Bash即说明安装成功： 2.使用git 我们一般最常用的就是git clone 命令来从gitee或者github上面拷贝项目到本地，你可以在电脑任意位置右键，然后会有git bash 命令，如下所示： 点击打开后在终端输入git clone + 项目地址，对于我们本项目来说，项目地址就是点这里复制下来： 对了，在终端的粘贴是右键，然后paste： 3.使用VS Code进行上传代码 首先下载vs code，但我没记错的话，不翻墙的情况下下载的十分慢，但是大家不用担心，优秀的我已经帮大家找到了镜像下载链接： 1https://vscode.cdn.azure.cn/stable/b4c1bd0a9b03c749ea011b06c6d2676c8091a70c/VSCodeUserSetup-x64-1.57.0.exe 下载好后，用vs code打开我们项目的文件夹，由于文件夹里面有 .gitee文件， 所以vscode十分智能的帮我们连接了远程的仓库，也就是说，你以后在vscode里面操作，最后点击上传，直接就上传到仓库了。 4.上传代码细节 一定要严格遵守，耽误不了多少时间！！！ 一定要严格遵守，耽误不了多少时间！！！ 一定要严格遵守，耽误不了多少时间！！！ 4.1写代码 对于我本人来说，我是喜欢一边看题目，一边用Dev c++敲代码，选择Dev c++原因有三个： 页面简洁； 可以调试不编译（也就是说不会生成exe文件），如果生成了exe文件，提交的话会搞得项目很大，所以我们只提交cpp文件； PTA，天梯赛好像都是之只能使用Dev c++，现在适应了，比赛时候会轻松不少。 这是我的刷题姿势：（提交成功后直接ctrl+s保存到文件夹中） 4.2提交代码 上面用Dev c++保存好之后，用VScode打开项目文件夹，你做了什么增删改操作，vscode都能检测到： 每次提交之前，在README.md里面填写一下信息，按照上面的格式复制粘贴就好： 然后，你需要填写你操作的是啥，这样的备注可以简写，几个字概括就好，点击提交，然后点击同步，显示下面界面就说明提交成功： 5.QQ群 以上就是所有流程，不难，一步步来肯定会成功，有任何问题及时在群里交流，QQ群："},{"title":"friends","date":"2022-09-06T12:28:12.000Z","updated":"2022-09-07T07:00:07.599Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"通知！","slug":"通知！","date":"2023-02-18T12:33:00.000Z","updated":"2023-02-18T12:37:56.556Z","comments":true,"path":"2023/02/18/通知！/","link":"","permalink":"http://example.com/2023/02/18/%E9%80%9A%E7%9F%A5%EF%BC%81/","excerpt":"","text":"这个网址更新了，因为我的github用户名改成了Li-Jihong，本网址是通过github创建的，所以之前的域名无法访问，要通过下面的域名访问： https://li-jihong.github.io/ 谨以此网页，献给一个女孩 (li-jihong.github.io)","categories":[{"name":"通知","slug":"通知","permalink":"http://example.com/categories/%E9%80%9A%E7%9F%A5/"}],"tags":[{"name":"更新","slug":"更新","permalink":"http://example.com/tags/%E6%9B%B4%E6%96%B0/"}],"author":"Li Jihong"},{"title":"算法代码1~2","slug":"算法代码1-2","date":"2023-01-13T13:46:00.000Z","updated":"2023-01-13T13:47:04.711Z","comments":true,"path":"2023/01/13/算法代码1-2/","link":"","permalink":"http://example.com/2023/01/13/%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%811-2/","excerpt":"第一阶段： 快速排序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 10;int n;int q[N];//快速排序void quick_sort(int s[], int l, int r)&#123; if (l &lt; r) &#123; //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quick_sort(s, l, i - 1); // 递归调用 quick_sort(s, i + 1, r); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]); return 0; &#125;","text":"第一阶段： 快速排序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;const int N = 10;int n;int q[N];//快速排序void quick_sort(int s[], int l, int r)&#123; if (l &lt; r) &#123; //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 int i = l, j = r, x = s[l]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j] &gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i] &lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quick_sort(s, l, i - 1); // 递归调用 quick_sort(s, i + 1, r); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]); return 0; &#125; 第k个数： 给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。 输入格式 第一行包含两个整数n和k。 第二行包含n个整数(所有整数均在1~1e9范围内)，表示整数数列。 输出格式 输出一个整数，表示数列的第k小数。 数据范围 1 ≤ n ≤ 100000, 1 ≤ k ≤ n 输入样例: 5 3 2 4 1 5 3 输出样例: 3 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;const int N = 100000 + 10;int n, k;int q[N];int quick_sort(int l, int r, int k)&#123; if(l &gt;= r) return q[l]; int x = q[l], i = l - 1, j = r + 1; while(i &lt; j)&#123; while(q[ ++i] &lt; x); while(q[ --j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; int sl = j - l + 1; if(k &lt;= sl) return quick_sort(l, j, k); return quick_sort(j + 1, r, k - sl);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i]; cout &lt;&lt; quick_sort(0, n - 1, k) &lt;&lt; endl; return 0;&#125; 二分查找 ： 输入： 测试数据的第一行输入n，m表示数组的长度和询问的次数(1&lt;=n,m&lt;=105) 接下来一行是 n 个数字A0 . . . An-1 满足 Ai&lt;=Ai+1 (1&lt;=Ai&lt;=109) 然后输入m行，每行是一个数字Qi表示询问(1&lt;=Qi&lt;=109) 输出： 对于每个询问，如果Qi在数组中出现过， 输出两个数字分别第一次出现和最后一次出现的位置， 如果Qi在数组中没有出现，则输出“-1 -1” 输入样例： 10 3 3 3 3 5 5 5 6 7 7 7 5 6 10 输出样例： 3 5 6 6 -1 -1 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, m;int q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]); while(m--)&#123; int x; scanf(&quot;%d&quot;, &amp;x); int l = 0, r = n- 1;//下面查找左边界 while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1;//mid=(l+r)/2 向下取整; if(q[mid] &gt;= x) r = mid; else l = mid + 1; &#125; if(q[l] != x) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; //找不到 else&#123; cout&lt;&lt; l &lt;&lt; &#x27; &#x27;;//输出左边界 int l = 0, r = n- 1;//下面查找右边界 while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1;//mid=(l+r+1)/2 向上取整; if(q[mid] &lt;= x) l = mid; else r = mid - 1; &#125; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125; return 0;&#125; 浮点数二分查找: 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int main()&#123; double x; cin&gt;&gt;x; double l = 0, r = x; while(r - l &gt; 1e-8)&#123; double mid = (l + r) / 2; if(mid * mid &gt;= x) r = mid; else l = mid; &#125; //浮点数不用考虑边界问题，太简单了 //如果保留四位小数， r - l &gt; 1e-6 (类比可得，永远多二，总会有保证) //如果保留六位小数， r - l &gt; 1e-8 (类比可得，永远多二，总会有保证) printf(&quot;%lf\\n&quot;, l); return 0;&#125; 归并排序: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;const int N = 1000010;int n;int q[N], tmp[N];void merge_sort(int q[], int l, int r)&#123; if(l &gt;= r) return; // int mid = l + r &gt;&gt; 1; int mid = (l + r)/2; merge_sort(q, l, mid), merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r)&#123; if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k++] = q[j++]; &#125; while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; for(i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]); merge_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]); return 0;&#125; 逆序对的数量： 给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下:对于数列的第i个和第j个元素，如果满i&lt;j且a[i]&gt; a[j]，则其为一个逆序对;否则不是。 输入格式 第一行包含整数n，表示数列的长度。 第二行包含n个整数，表示整个数列。 输出格式 输出一个整数，表示逆序对的数量。 数据范围 1 ≤ n ≤ 100000 输入样例: 6 2 3 4 5 6 1 输出样例: 5 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;typedef long long LL;const int N = 100000 + 10;int n;int q[N], tmp[N];LL merge_sort(int l, int r)&#123; if(l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(l, mid) + merge_sort(mid + 1, r); //归并的过程 int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r)&#123; if(q[i] &lt;= q[j]) tmp[k++] = q[i++]; else&#123; tmp[k++] = q[j++]; res += mid - i + 1; &#125; &#125; //扫尾 while(i &lt;= mid) tmp[k++] = q[i++]; while(j &lt;= r) tmp[k++] = q[j++]; //物归原主 for(int i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j]; return res;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) cin &gt;&gt; q[i]; cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl; return 0;&#125; 高精度加法: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 10;// C = A + Bvector&lt;int&gt; add (vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; int t = 0; //上一位的进位，第一次为0 for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123; if(i &lt; A.size()) t += A[i]; //如果A[i]这一位有的话就加上A[i] if(i &lt; B.size()) t += B[i]; //如果B[i]这一位有的话就加上B[i] C.push_back(t % 10); t /= 10; &#125; if(t) C.push_back(1); //看一下最高位有没有进位，有的话就进位1 return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin&gt;&gt;a&gt;&gt;b; // a = &quot;123456&quot; for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#x27;0&#x27;); // A =[6, 5, 4, 3, 2, 1] for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#x27;0&#x27;); auto C = add(A, B); for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]); return 0;&#125; 高精度减法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 10;//判断是否有A &gt;= Bbool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i--) if(A[i] != B[i]) return A[i] &gt; B[i]; return true;&#125;// C = A - Bvector&lt;int&gt; sub (vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for(int i = 0, t = 0; i &lt; A.size(); i++)&#123; t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin&gt;&gt;a&gt;&gt;b; // a = &quot;123456&quot; for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#x27;0&#x27;); // A =[6, 5, 4, 3, 2, 1] for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - &#x27;0&#x27;); if(cmp(A, B))&#123; auto C = sub(A, B); for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]); &#125; else&#123; auto C = sub(A, B); printf(&quot;-&quot;); for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]); &#125; return 0;&#125; 高精度乘法: 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// C = A * bvector&lt;int&gt; mul (vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; //进位 for(int i = 0; i &lt; A.size() || t; i++)&#123; if(i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; return C;&#125;int main()&#123; string a; int b; cin&gt;&gt;a&gt;&gt;b; vector&lt;int&gt; A; for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#x27;0&#x27;); auto C = mul(A, b); for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]); return 0;&#125; 高精度除法: 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;// A / b 商是C，余数是rvector&lt;int&gt; div (vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for(int i = A.size() - 1; i &gt;= 0; i--)&#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //去除前导0 return C;&#125;int main()&#123; string a; int b; cin&gt;&gt;a&gt;&gt;b; vector&lt;int&gt; A; for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - &#x27;0&#x27;); int r; auto C = div(A, b, r); for(int i = C.size() - 1; i &gt;= 0; i--) printf(&quot;%d&quot;, C[i]); cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl; return 0;&#125; 一维前缀和： 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123; // ios::sync_with_stdio(false); //好处：可以提高cin的输入效率；坏处：后面都不能用scanf了。 scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; //前缀和的初始化 while(m--)&#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); //区间和的计算 &#125; return 0;&#125; 一维前缀和练习： 输入一个长度为n的整数序列。 接下来再输入m个询问，每个询问输入一对l, r。 对于每个询问，输出原序列中从第|个数到第r个数的和。 输入格式 第一行包含两个整数n和m。 第二行包含n个整数，表示整数数列。 接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。 输出格式 共m行，每行输出一个询问的结果。 数据范围 1≤l≤r ≤ n, 1 ≤n, m ≤ 100000, —1000≤数列中元素的值≤1000 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;const int N = 100000 + 10;int n,m;int a[N], s[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[n]); //求前缀和数组 for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; while(m--)&#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 二维前缀和： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], s[N][N];int main()&#123; // ios::sync_with_stdio(false); //好处：可以提高cin的输入效率；坏处：后面都不能用scanf了。 scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) for(int j = 1; i &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 1; i &lt;= m; j++) s[i][j] = s[i -1][j] + s[i][j - 1] - s[i -1 ][j - 1] + a[i][j]; //求前缀和 while(q--)&#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); //算子矩阵和 &#125; return 0;&#125; 二维前缀和练习： 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1,x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数n，m，q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含四个整数×1,y1,x2, y2，表示一组询问。 输出格式 共q行，每行输出一个询问的结果。 数据范围： 1 ≤n, m ≤1000, 1≤q≤100000, 1 &lt;c1 ≤a2 ≤n,1&lt; y1 ≤y2 ≤ m, -1000≤矩阵内元素的值≤1000 输入样例: 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例: 17 27 21 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], s[N][N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); //初始化前缀和数组 for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) s[i][j] = s[i - 1][j] + s[i][j - 1] -s[i - 1][j - 1] + a[i][j]; //询问 while(q--)&#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); //算子矩阵和 &#125; return 0;&#125; 一维差分： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N];void insert(int l, int r, int c)//一维差分的核心&#123; b[l] += c; b[r + 1] -= c;&#125;int main()&#123; // ios::sync_with_stdio(false); //好处：可以提高cin的输入效率；坏处：后面都不能用scanf了。 scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i++) insert(i, i, a[i]); while(m--)&#123; int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for(int i = 1; i &lt;= n; i++) b[i] += b[i - 1]; //a[i] = a[i - 1] + b[i]; for(int i = 1; i &lt;= n; i++) printf(&quot;%d &quot;, b[i]); //printf(&quot;%d &quot;, a[i]) return 0;&#125; 二维差分： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c) //二维差分的核心&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c;&#125;int main()&#123; // ios::sync_with_stdio(false); //好处：可以提高cin的输入效率；坏处：后面都不能用scanf了。 scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;a[i][j]); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) insert(i, j, i, j, a[i][j]); while(q--)&#123; int x1, y1, x2, y2, c; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c; insert(x1, y1, x2, y2, c); &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i -1][j - 1]; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) printf(&quot;%d &quot;, b[i][j]); puts(&quot;&quot;); &#125; return 0;&#125; 双指针算法: **问题：**给定一个长度为n的整数序列，请找出最长的不包含重复数字的连续子序列，输出它的长度。 输入格式: 第一行包含整数n。 第二行包含n个整数(均在0~100000范围内)，表示整数序列。 输出格式: 共一行，包含一个整数，表示最长的不包含重复数字的连续子序列的长度。 数据范围: 1≤n ≤100000 输入样例: 5 1 2 2 3 5 输出样例: 3 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 100010;int n;int a[N], s[N];int main()&#123; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) cin&gt;&gt;a[i]; int res = 0; for(int i = 0, j = 0; i &lt; n; i++)&#123; s[a[i]] ++; while(s[a[i]] &gt; 1)&#123; s[a[j]] -- ; j++; &#125; res = max(res, i - j + 1); &#125; cout&lt;&lt; res &lt;&lt; endl; return 0;&#125; //双指针算法的逻辑结构： /* for(int i = 0; i &lt; n; i++){ while(j &lt; i &amp;&amp; check(i,j)) j++; res = amx(res, i - j + 1) //每道题的具体逻辑 } */ //核心思想：将O（n2） =&gt; O(n) // 常见问题分类: // (1)对于—个序列，用两个指针维护—段区间 // (2)对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算： **问题：**给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。 输入格式: 第一行包含整数n。 第二行包含n个整数，表示整数序列。 输出格式: 共一行，包含n个整数，其中的第i个数表示数列中的第i个数的二进制表示中1的个数。 数据范围: 1≤n ≤100000 0≤数列中元素的值≤1e9 输入样例: 5 1 2 3 4 5 输出样例: 1 1 2 1 2 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int lowbit(int x)&#123;//返回x的最后一位1 return x &amp; -x;&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--)&#123; int x; cin&gt;&gt;x; int res = 0; while(x) x-= lowbit(x), res++; //每次减去x的最后一位1 cout&lt;&lt;res&lt;&lt;&#x27; &#x27;; &#125; return 0;&#125;//求n的第k位数字： n &gt;&gt; k &amp; 1 离散化: 离散化:特指整数的保序的离散化 vector alls;//存储所有待离散化的值 sort(alls.begin(), alls.end());//将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end());//去掉重复元素 unique()函数返回最后的下标，erase()函数删除一段区间的值。 */ /* 二分求出x对应的离散化的值 int find(int x){//找到第一个大于等于x的位置 int l, r = alls.size() - 1; while(l &lt; r){ ​ int mid = l + r &gt;&gt;1; ​ if(alls[mid] &gt;= x) r = mid; ​ else l = mid + 1; //映射到1，2，3…n } return r + 1; } */ 假定有一个无限长的数轴，数轴上每个坐标上的数都是0。 现在，我们首先进行n次操作，每次操作将某一位置x上的数加c。 近下来，进行m次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。 输入格式: 第一行包含两个整数n和m。 接下来n行，每行包含两个整数x和c。 再接下里m行，每行包含两个整数l和r。 输出格式: 共m行，每行输出一个询问中所求的区间内数字和。 数据范围: -1e9 &lt;= x &lt;= 1e9, 1 ≤ n, m ≤ 1e5, —1e9 &lt;= l &lt;= r &lt;= 1e9, -1e5 ≤ c ≤ 1e5, 输入样例: 3 3 1 2 3 6 7 5 1 3 4 6 7 8 输出样例: 8 0 5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;vector&gt; //用vector来做离散化#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300000 + 10;int n, m;int a[N], s[N];vector&lt;int&gt; alls;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = alls.size() - 1; while(l &lt; r)&#123; int mid = l + r &gt;&gt;1; if(alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++)&#123; int x, c; cin&gt;&gt;x&gt;&gt;c; add.push_back(&#123;x,c&#125;); alls.push_back(x); &#125; for(int i = 0; i &lt; m; i++)&#123; int l, r; cin&gt;&gt;l&gt;&gt;r; query.push_back(&#123;l,r&#125;); alls.push_back(l); alls.push_back(r); &#125; //去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); for(auto item : add)&#123; int x = find(item.first); a[x] += item.second; &#125; //预处理前缀和 for(int i= 1; i &lt;= alls.size(); i++) s[i] = s[i - 1] + a[i]; //处理询问 for(auto item : query)&#123; int l = find(item.first), r = find(item.second); cout&lt;&lt;s[r] - s[l - 1]&lt;&lt;endl; &#125; return 0;&#125; 区间合并： 问题： 给定n个区间[l, r]，要求合并所有有交集的区间。 注意如果在端点处相交，也算有交集。 输出合并完成后的区间个数。 例如:[1,3]和[2,6]可以合并为一个区间[1,6]。 输入格式: 第一行包含整数n。 接下来n行，每行包含两个整数l和r。 输出格式: 共一行，包含—个整数，表示合并区间完成后的区间个数。 数据范围: 1≤ n ≤100000 -1e9 &lt;= l &lt;= r &lt;= 1e9 输入样例: 5 1 2 2 4 5 6 7 8 7 9 输出样例: 3 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt; //用vector来做离散化#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1000000 + 10;int n;vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for(auto seg : segs)&#123; if(ed &lt; seg.first)&#123; if(st != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); &#125; if(st != -2e9) res.push_back(&#123;st, ed&#125;); segs = res;&#125;int main()&#123; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++)&#123; int l, r; cin&gt;&gt;l&gt;&gt;r; segs.push_back(&#123;l,r&#125;); &#125; merge(segs); cout&lt;&lt;segs.size()&lt;&lt;endl; return 0;&#125; 数的三次方根： 问题描述： 给定一个浮点数n，求他的三次方根。 输入格式 共一行，包含浮点数n。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留六位小数。 数据范围： -10000&lt;=n&lt;=10000 输入样例: 1000.00 输出样例: 10.000000 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -10000, r = 10000; while(r - l &gt; 1e-8) &#123; double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; &#125; printf(&quot;%.6lf\\n&quot;, l); return 0;&#125; 第二阶段： 链表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int N = 100010;//head表示头结点的下标//e[i]表示节点i的值//ne[i]表示i的next指针是多少//idx存储当前用到了哪个点int head, e[N], ne[N], idx;//初始化void init()&#123; head = -1; idx = 0;&#125;//将x插到头节点void add_to_head(int x)&#123; e[idx] = x; ne[idx] = head; head = idx; idx++;&#125;//将x插到下标是k的点的后面void add(int k, int x)&#123; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx; idx ++;&#125;//将下标是k的点后面的点删掉void remove(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; return 0;&#125; 双链表： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 100010;int m;int e[N], l[N], r[N], idx;//初始化void init()&#123; //0表示左端点，1表示右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;//在下标是k的点的右边，插入xvoid add(int k, int x)&#123; e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx;&#125;//删除第k个点void remove(int k)&#123; r[l[k]] = r[k]; l[r[k]] = l[k];&#125; 栈和队列： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N = 100010;int stk[N], tt;//************************** 栈//插入stk[++tt] = x;//弹出tt --;//判断栈是否为空if(tt &gt; 0) not empty;else empty;//栈顶stk[tt];//************************** 队列int q[N], hh , tt = -1;//插入q[++ t] = x;//弹出hh++;//判断队列是否为空if(hh &lt;= tt) not empty;else empty;//取出队头元素q[hh] 单调队列-滑动窗口： 输入数据： 8 3 1 3 -1 -3 5 3 6 7 输出数据： -1 -3 -3 -3 3 3 3 3 5 5 6 7 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1000010;int n, k;int a[N], q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0 ; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) &#123; //判断队头是否已经滑出了窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--; q[++ tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); &#125; puts(&quot;&quot;); hh = 0, tt = -1; for(int i = 0; i &lt; n; i++) &#123; //判断队头是否已经滑出了窗口 if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--; q[++ tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); &#125; puts(&quot;&quot;); return 0;&#125; KMP： 输入数据： 3 aba 5 ababa 输出数据： 0 2 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 10010, M = 100010;int n, m;char p[N], s[M];int ne[N];int main()&#123; cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; //求next的过程 for(int i = 2, j = 0; i &lt;= n; i++)&#123; while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j++; ne[i] = j; &#125; //kmp过程 for(int i = 1, j = 0; i&lt;= m; i++)&#123; while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j++; if(j == n)&#123; printf(&quot;%d &quot;, i - n); j = ne[j]; &#125; &#125; return 0;&#125; Trie树： 用来高效的存储和查找字符串数组 问题描述： 维护一个字符串集合，支持两种操作： ”I x“向集合中插入一个字符串x ”Q x“询问一个字符串在一个集合中出现了多少次 共有N个操作,输入的字符串总长度不超过1e5,字符串仅包含小写英文字母。**** 输入格式: 第一行包含整数N,表示操作数。 接下来N行，每行包含一个操作指令, 指令为&quot;Ix&quot;或&quot;Q x&quot;中的一种。**** 输出格式: 对于每个询问指令&quot;Q x&quot;,都要输出一个整数作为结果，表示x在集合中出现的次数。 每个结果占一行。 数据范围: 1≤ N ≤2* 1e4 输入样例： 5 I abc Q abc Q ab I ab Q ab 输出样例： 1 0 1 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 100010;int son [N][26], cnt[N], idx;// 下标是0的点，既是根节点，又是空节点char str[N];void insert(char str[])&#123; int p = 0; for(int i = 0; str[i]; i++)&#123; int u = str[i] - &#x27;a&#x27;; //映射从 ’a‘ ——&gt; 25 if(!son[p][u]) son[p][u] = ++ idx; //如果不存在就创建出来 p = son[p][u]; &#125; cnt[p] ++;&#125;int query(char str[])&#123; int p = 0; for(int i = 0; str[i]; i++)&#123; int u = str[i] - &#x27;a&#x27;; //映射从 ’a‘ ——&gt; 25 if(!son[p][u]) return 0; p = son[p][u]; &#125; return cnt[p]; //返回以p结尾的字母数量&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); while(n --)&#123; char op[2]; scanf(&quot;%s%s&quot;, op, str); if(op[0] == &#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;, query(str)); &#125; return 0;&#125; 合并集合： 并查集: 1.将两个集合合并 2.询问两个元素是否在一 个集合当中 基本原理:每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储 它的父节点，p[x]表示x的父节点 问题1:如何判断树根: if (p[x] == x) 问题2:如何求x的集合编号: while (p[x]!= x)x = p[x]; 问题3:如何合并两个集合: px是x的集合编号，py是y的集合编号。p[x] =y 问题描述： 一共有n个数，编号是1~n，最开始每个数各自在一个集合中。 现在要进行m个操作,操作共有两种: “M a b”,将编号为a和b的两个数所在的集合合并,如果两个数已经在同一个集合中，则忽略这个操作; “Q a b”,询问编号为a和b的两个数是否在同一个集合中; 输入格式： 第一行输入整数n和m。 接下来m行，每行包含一个操作指令,指令为&quot;M a b&quot;或&quot;Qa b”中的一-种。 输出格式： 对于每个询问指令&quot;Qab&quot;,都要输出一个结果,如果a和b在同-集合内,则输出&quot;Yes&quot;, 否则输出&quot;No&quot;。 每个结果占一行。 数据范围： 1 ≤ n,m≤1e5 输入样例： 4 5 M 1 2 M 3 4 Q 1 2 Q 1 3 Q 3 4 输出样例： Yes No Yes 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int p[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) p[i] = i; while(m --)&#123; char op[2]; int a, b; scanf(&quot;%s%d%d&quot;, op, &amp;a, &amp;b); if(op[0] == &#x27;M&#x27;) p[find(a)] = find(b); else&#123; if(find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 联通块中点的数量： 问题描述： 给定一个包含n个点(编号为1~n)的无向图,初始时图中没有边。 现在要进行m个操作,操作共有三种: . 1.“C a b”,在点a和点b之间连一条边, a和b可能相等; 2.“Q1 a b”,询问点a和点b是否在同-一个连通块中, a和b可能相等; 3.“Q1 a”,询问点a所在连通块中点的数量; 输入格式： 第一行输入整数n和m。 接下来m行，每行包含一个操作指令，指令为&quot;C a b&quot;, “Q1 a b&quot;或&quot;Q2 a&quot;中的一-种。 输出格式： 对于每个询问指令&quot;Q1 a b&quot;,如果a和b在同一个连通块中,则输出&quot;Yes&quot;, 否则输出“No&quot;。 对于每个询问指令“Q2 a&quot;,输出一个整数表示点a所在连通块中点的数量 每个结果占一行。 数据范围： 1 ≤ n,m≤1e5 输入样例： 5 5 C 1 2 Q1 1 2 Q2 1 C 2 5 Q2 5 输出样例： Yes 2 3 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int p[N], size[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; p[i] = i; size[i] = 1; &#125; while(m --)&#123; char op[5]; int a, b; scanf(&quot;%s&quot;, op); if(op[0] == &#x27;C&#x27;) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if(find(a) == find(b)) continue; size[find(b)] += size[find(a)]; p[find(a)] = find(b); &#125; else if(op[1] == &#x27;1&#x27;)&#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if(find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; else&#123; scanf(&quot;%d&quot;, &amp;a); printf(&quot;%d\\n&quot;, size[find(a)]); &#125; &#125; return 0;&#125; 堆： 问题描述： 输入一个长度为n的整数数列，从小到大输出前m小的数。 输入格式： 第一行包含整数n和m. 第二行包含n个整数,表示整数数列。 输出格式： 共一行,包含m个整数,表示整数数列中前m小的数。 数据范围： 1 ≤ n,m≤1e5 1 ≤数列中的元素 n,m≤1e9 输入样例： 5 3 4 5 1 3 2 输出样例： 1 2 3 如何手写一一个堆? 1.插入一个数 heap[ ++ size] = x; up(size); 2.求集合当中的最小值 heap[1]; 3.删除最小值 heap[1] = heap[size]; szie – ; down(1); 4.删除任意一个元素 heap[k] = heap[size]; size – ; down(k); up(k); 5.修改任意一个元素 heap[k] = X; down(k); up(k); 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], size;void down(int u)&#123; int t = u; if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t)&#123; swap(h[u], h[t]); down(t); &#125;&#125;void up(int u)&#123; while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; swap(h[u / 2], h[u]); u /= 2; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;h[i]); size = n; for(int i = n / 2; i; i--) down(i); while(m --)&#123; printf(&quot;%d &quot;, h[1]); h[1] = h[size]; size --; down(1); &#125; return 0;&#125; 模拟堆： 问题描述： 维护一个集合,初始时集合为空，支持如下几种操作: 1.“1x”.插入一个数x; 2.“PM&quot;,输出当前集合中的最小值; 3.“DM”,删除当前集合中的最小值(当最小值不唯一时,删除最早插入的最小值) ; 4.“D k”,删除第k个插入的数; 5.“C k x”,修改第k个插入的数,将其变为x; 现在要进行N次操作，对于所有第2个操作，输出当前集合的最小值。 输入格式： 第一行包含整数N。 接下来N行，每行包含一个操作指令, 操作指令为&quot;1x&quot;, “PM”, “DM”, &quot;D K&quot;或&quot;C k x&quot;中的-种。 输出格式： 对于每个输出指令&quot;PM&quot;,输出一个结果，表示当前集合中的最小值。 每个结果占一行。 数据范围： 1 ≤N≤1e5 -1e9≤x≤1e9 输入样例： 10 I -10 PM I -10 D 1 C 2 8 I 6 PM DM 输出样例： -10 6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], size;void heap_swap(int a, int b)&#123; swap(ph[hp[a]], ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t)&#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) &#123; heap_swap(u / 2, u); u /= 2; &#125;&#125;int main()&#123; int n, m; scanf(&quot;%d&quot;, &amp;n); while(n--) &#123; char op[10]; int k, x; scanf(&quot;%s&quot;, op); if(!strcmp(op, &quot;I&quot;))&#123; scanf(&quot;%d&quot;, &amp;x); size++; m++; ph[m] = size, hp[size] = m; h[size] = x; up(size); &#125; else if(!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]); else if(!strcmp(op, &quot;DM&quot;)) &#123; heap_swap(1, size); size --; down(1); &#125; else if(!strcmp(op, &quot;D&quot;)) &#123; scanf(&quot;%d&quot;, &amp;k); k = ph[k]; heap_swap(k, size); size--; down(k), up(k); &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;k, &amp;x); k = ph[k]; h[k] = x; down(k), up(k); &#125; &#125; return 0;&#125; 哈希表： 问题描述： 维护一个集合,支持如下几种操作: 1.“I x”,插入一个数x; 2.“Q x”,询问数x是否在集合中出现过; 现在要进行N次操作，对于每个询问操作输出对应的结果。 输入格式： 第一行包含整数N，表示操作数量。 接下来N行，每行包含一个操作指令,操作指令为&quot;Ix&quot;, &quot;Q x”中的一种。 输出格式： 对于每个询问指令“Q x&quot;，输出一个询问结果，如果x在集合中出现过,则输出&quot;Yes&quot;, 否则输出&quot;No&quot;。 每个结果占一行。 数据范围： 1 ≤N≤1e5 -1e9≤x≤1e9 输入样例： 5 I 1 I 2 I 3 Q 2 Q 5 输出样例： Yes No 拉链法： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x)&#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx++;&#125;bool find(int x)&#123; int k = (x % N + N) % N; for(int i = h[k]; i != -1; i++)&#123; if(e[i] == x) return true; &#125; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof h); while(n--)&#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if(*op == &#x27;I&#x27;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 开放寻址法： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123; int k = (x % N + N) % N; while(h[k] != null &amp;&amp; h[k] != x)&#123; k++; if(k == N) k = 0; &#125; return k;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(h, 0x3f, sizeof h); while(n--)&#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); int k = find(x); if(*op == &#x27;I&#x27;)&#123; h[k] = x; &#125; else &#123; if(h[k] != null) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 字符串哈希： 问题描述： 给定一个长度为n的字符串， 再给定m个询问，每个询问包含四个整数l,r1,l2,r2,请你判断[l1, r1]和[l2,r2]这 两个区间所包含的字符串子串是否完全相同。 字符串中只包含大小写英文字母和数字。 输入格式： 第一行包含整数n和m,表示字符串长度和询问次数。 第二行包含一个长度为n的字符串,字符串中只包含大小写英文字母和数字。 接下来m行,每行包含四个整数61,r1,l2,r2,表示一次询问所涉及的两个区间。 注意，字符串的位置从1开始编号。 输出格式： 对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes&quot;,否则输出“No&quot;。 每个结果占一行。 数据范围： 1 ≤n,m≤1e5 输入样例： 8 3 aabbaabb 1 3 5 7 1 3 6 8 1 2 1 2 输出样例： Yes No Yes 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); p[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125; while(m--)&#123; int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if(get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125; STL:","categories":[{"name":"算法模板","slug":"算法模板","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"Li Jihong"},{"title":"感慨","slug":"感慨","date":"2023-01-13T13:44:00.000Z","updated":"2023-01-13T13:45:09.664Z","comments":true,"path":"2023/01/13/感慨/","link":"","permalink":"http://example.com/2023/01/13/%E6%84%9F%E6%85%A8/","excerpt":"","text":"一寸土一年木一花一树一贪图 情是种爱偏开在迷途 忘前路忘旧物忘心忘你忘最初 花斑斑留在爱你的路 虔诚夙愿来世路 一念桃花因果渡 那一念几阙时光在重复 听雨书望天湖人间寥寥情难诉 回忆斑斑留在爱你的路","categories":[{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Li Jihong"},{"title":"加入《Dev_cpp代码》代码库的操作手册","slug":"加入《Dev-cpp代码》代码库的操作手册","date":"2022-10-30T18:10:00.000Z","updated":"2022-10-30T18:15:18.853Z","comments":true,"path":"2022/10/31/加入《Dev-cpp代码》代码库的操作手册/","link":"","permalink":"http://example.com/2022/10/31/%E5%8A%A0%E5%85%A5%E3%80%8ADev-cpp%E4%BB%A3%E7%A0%81%E3%80%8B%E4%BB%A3%E7%A0%81%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/","excerpt":"考虑到加入我们的代码库以后可能会有源源不断的人加入，so，鄙人打算写一个详细的操作手册告诉后人如何操作（在此不得不吐槽hlh同学，我诚心邀请他和我一起编写此手册，他居然因为懒直接一口拒绝了我。。） 1.安装git https://git-scm.com 这是git的官网 进入后点击Downloads，下载下面的这个版本：","text":"考虑到加入我们的代码库以后可能会有源源不断的人加入，so，鄙人打算写一个详细的操作手册告诉后人如何操作（在此不得不吐槽hlh同学，我诚心邀请他和我一起编写此手册，他居然因为懒直接一口拒绝了我。。） 1.安装git https://git-scm.com 这是git的官网 进入后点击Downloads，下载下面的这个版本： 然后就是安装，按理说没什么特别需要注意的，一直点击next就行，特别提醒，最好将安装位置放到D盘，并且给文件夹命个简约的名（如果你C盘没有分盘，那当我没说）。 怎么检验是否安装成功了呢？ win+R输入cmd，在这里输入git --version，出现 git GUI 和 git Bash即说明安装成功： 2.使用git 我们一般最常用的就是git clone 命令来从gitee或者github上面拷贝项目到本地，你可以在电脑任意位置右键，然后会有git bash 命令，如下所示： 点击打开后在终端输入git clone + 项目地址，对于我们本项目来说，项目地址就是点这里复制下来： 对了，在终端的粘贴是右键，然后paste： 3.使用VS Code进行上传代码 首先下载vs code，但我没记错的话，不翻墙的情况下下载的十分慢，但是大家不用担心，优秀的我已经帮大家找到了镜像下载链接： 1https://vscode.cdn.azure.cn/stable/b4c1bd0a9b03c749ea011b06c6d2676c8091a70c/VSCodeUserSetup-x64-1.57.0.exe 下载好后，用vs code打开我们项目的文件夹，由于文件夹里面有 .gitee文件， 所以vscode十分智能的帮我们连接了远程的仓库，也就是说，你以后在vscode里面操作，最后点击上传，直接就上传到仓库了。 4.上传代码细节 一定要严格遵守，耽误不了多少时间！！！ 一定要严格遵守，耽误不了多少时间！！！ 一定要严格遵守，耽误不了多少时间！！！ 4.1写代码 对于我本人来说，我是喜欢一边看题目，一边用Dev c++敲代码，选择Dev c++原因有三个： 页面简洁； 可以调试不编译（也就是说不会生成exe文件），如果生成了exe文件，提交的话会搞得项目很大，所以我们只提交cpp文件； PTA，天梯赛好像都是之只能使用Dev c++，现在适应了，比赛时候会轻松不少。 这是我的刷题姿势：（提交成功后直接ctrl+s保存到文件夹中） 4.2提交代码 上面用Dev c++保存好之后，用VScode打开项目文件夹，你做了什么增删改操作，vscode都能检测到： 每次提交之前，在README.md里面填写一下信息，按照上面的格式复制粘贴就好： 然后，你需要填写你操作的是啥，这样的备注可以简写，几个字概括就好，点击提交，然后点击同步，显示下面界面就说明提交成功： 5.QQ群 以上就是所有流程，不难，一步步来肯定会成功，有任何问题及时在群里交流，QQ群：","categories":[{"name":"代码库","slug":"代码库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"},{"name":"gitee","slug":"gitee","permalink":"http://example.com/tags/gitee/"}],"author":"Li Jihong"},{"title":"LeetCode刷题","slug":"LeetCode刷题","date":"2022-10-30T16:10:20.927Z","updated":"2022-09-07T06:52:25.850Z","comments":true,"path":"2022/10/31/LeetCode刷题/","link":"","permalink":"http://example.com/2022/10/31/LeetCode%E5%88%B7%E9%A2%98/","excerpt":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;;","text":"LeetCode刷题记录 贪心算法 435——无重叠区间 2022-08-014 方法1.动态规划 思路: dp[i]表示前i个区间中最大不重合区间的个数，首先将区间数组按左边界排序，找出intervals中最多有多少个不重复的区间，动态规划方程dp[i] = Math.max(dp[i]，dp[j] + 1)。intervals的长度减去最多的不重复的区间就是最少删除区间的个数 复杂度:时间复杂度0(n^2)，两层嵌套循环leetcode执行超时复杂度过高。空间复杂度0(n), dp数组的空间 javascript 123456789101112131415161718192021//leetcode执行超时 复杂度过高var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; intervals.sort((a, b) =&gt; a[0] - b[0]); //按左边界排序 const n = intervals.length; const dp = new Array(n).fill(1); //初始化dp数组 for (let i = 1; i &lt; n; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; //循环i,j找出intervals中最多有多少个不重复的区间 //j的右边界小于i的左边界 相当于多出了一个不重合区间 if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i] &#125; &#125; &#125; return n - Math.max(...dp); //n减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 12345678910111213141516171819202122232425class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[0] - interval2[0]; &#125; &#125;); int n = intervals.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (intervals[j][1] &lt;= intervals[i][0]) &#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; return n - Arrays.stream(dp).max().getAsInt(); &#125;&#125; 方法2.贪心 思路：intervals按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多，intervals的长度减去最多的不重复的区间 就是最少删除区间的个数 复杂度：时间复杂度O(nlogn)，数组排序O(nlogn)，循环一次数组O(n)。空间复杂度O(logn)，排序需要的栈空间 javascript 123456789101112131415161718192021var eraseOverlapIntervals = function (intervals) &#123; if (!intervals.length) &#123; return 0; &#125; //按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多 intervals.sort((a, b) =&gt; a[1] - b[1]); const n = intervals.length; let right = intervals[0][1]; //right初始化为第一个区间的右边界 let ans = 1; //最多的不重合区间的个数 for (let i = 1; i &lt; n; ++i) &#123; //循环区间数组 if (intervals[i][0] &gt;= right) &#123; //当区间的左边界大于上一个区间的右边界的时候 说明是一对不重合区间 ++ans; //ans加1 right = intervals[i][1]; //更新right &#125; &#125; return n - ans; //intervals的长度减去最多的不重复的区间 就是最少删除区间的个数&#125;; java 123456789101112131415161718192021222324class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) &#123; return 0; &#125; Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] interval1, int[] interval2) &#123; return interval1[1] - interval2[1]; &#125; &#125;); int n = intervals.length; int right = intervals[0][1]; int ans = 1; for (int i = 1; i &lt; n; ++i) &#123; if (intervals[i][0] &gt;= right) &#123; ++ans; right = intervals[i][1]; &#125; &#125; return n - ans; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}],"author":"Li Jihong"},{"title":"Hello World","slug":"hello-world","date":"2022-10-30T16:10:20.920Z","updated":"2022-09-08T02:09:05.447Z","comments":true,"path":"2022/10/31/hello-world/","link":"","permalink":"http://example.com/2022/10/31/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"通知","slug":"通知","date":"2022-10-23T08:38:00.000Z","updated":"2022-10-23T08:44:08.613Z","comments":true,"path":"2022/10/23/通知/","link":"","permalink":"http://example.com/2022/10/23/%E9%80%9A%E7%9F%A5/","excerpt":"","text":"通知 由于精力不足，从今天起只在我新开的代码库更新代码，并且没有题目（自行搜索题目），代码库网址在这： https://gitee.com/ljh04250909/dev-cpp-code 欢迎大家访问！ Dev_cpp代码 介绍 用来记录我在Dev_cpp上面写的代码 打个小广告 我的个人博客网站欢迎大家访问：https://bh04250909.github.io/","categories":[{"name":"代码库","slug":"代码库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/"}],"tags":[{"name":"gitee","slug":"gitee","permalink":"http://example.com/tags/gitee/"}],"author":"Li Jihong"},{"title":"PTA天梯赛2022-10-10刷题","slug":"PTA天梯赛2022-10-10刷题","date":"2022-10-10T02:41:00.000Z","updated":"2022-10-10T02:56:06.309Z","comments":true,"path":"2022/10/10/PTA天梯赛2022-10-10刷题/","link":"","permalink":"http://example.com/2022/10/10/PTA%E5%A4%A9%E6%A2%AF%E8%B5%9B2022-10-10%E5%88%B7%E9%A2%98/","excerpt":"PTA-天梯赛——L1-030 一帮一 “一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的异性学生分为一组。 输入格式： 输入第一行给出正偶数N（≤50），即全班学生的人数。此后N行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。 输出格式： 每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。 输入样例： 12345678980 Amy1 Tom1 Bill0 Cindy0 Maya1 John1 Jack0 Linda 输出样例： 1234Amy JackTom LindaBill MayaCindy John","text":"PTA-天梯赛——L1-030 一帮一 “一帮一学习小组”是中小学中常见的学习组织方式，老师把学习成绩靠前的学生跟学习成绩靠后的学生排在一组。本题就请你编写程序帮助老师自动完成这个分配工作，即在得到全班学生的排名后，在当前尚未分组的学生中，将名次最靠前的学生与名次最靠后的异性学生分为一组。 输入格式： 输入第一行给出正偶数N（≤50），即全班学生的人数。此后N行，按照名次从高到低的顺序给出每个学生的性别（0代表女生，1代表男生）和姓名（不超过8个英文字母的非空字符串），其间以1个空格分隔。这里保证本班男女比例是1:1，并且没有并列名次。 输出格式： 每行输出一组两个学生的姓名，其间以1个空格分隔。名次高的学生在前，名次低的学生在后。小组的输出顺序按照前面学生的名次从高到低排列。 输入样例： 12345678980 Amy1 Tom1 Bill0 Cindy0 Maya1 John1 Jack0 Linda 输出样例： 1234Amy JackTom LindaBill MayaCindy John 我的写法 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;struct stu&#123; int sex; string name;&#125;;int main()&#123; int n=0; cin&gt;&gt;n; vector&lt;stu&gt; rank; for(int i=0;i&lt;n;i++) &#123; stu temp; cin&gt;&gt;temp.sex&gt;&gt;temp.name; rank.push_back(temp); &#125; for(int i=0;i&lt;rank.size();i++) &#123; for(int j=rank.size()-1;j&gt;0;j--) &#123; if(rank[i].sex!=rank[j].sex) &#123; cout&lt;&lt;rank[i].name&lt;&lt;&quot; &quot;&lt;&lt;rank[j].name&lt;&lt;endl; rank.erase(rank.begin()+j); break; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"刷题","slug":"C/刷题","permalink":"http://example.com/categories/C/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"http://example.com/tags/PTA/"},{"name":"天体赛","slug":"天体赛","permalink":"http://example.com/tags/%E5%A4%A9%E4%BD%93%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"PTA天体赛-简单题","slug":"PTA天体赛-简单题","date":"2022-09-25T07:18:00.000Z","updated":"2022-09-25T07:22:42.051Z","comments":true,"path":"2022/09/25/PTA天体赛-简单题/","link":"","permalink":"http://example.com/2022/09/25/PTA%E5%A4%A9%E4%BD%93%E8%B5%9B-%E7%AE%80%E5%8D%95%E9%A2%98/","excerpt":"今天做的是一些简单的题目，可以用弱智来形容了，但是最后一题你能想到比我更简单的做法吗？ C++要多看STL，多运用标准库函数，容器等等，达到熟练的水平。 PTA-天梯赛——L1-019 谁先倒 划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。 输入格式： 输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为： 1甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式： 在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。","text":"今天做的是一些简单的题目，可以用弱智来形容了，但是最后一题你能想到比我更简单的做法吗？ C++要多看STL，多运用标准库函数，容器等等，达到熟练的水平。 PTA-天梯赛——L1-019 谁先倒 划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。 输入格式： 输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为： 1甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式： 在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。 输入样例： 123456781 168 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 1515 1 1 16 输出样例： 12A1 我的解法 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;main()&#123; int a_max,b_max; //甲乙的酒量变量 scanf(&quot;%d %d&quot;,&amp;a_max,&amp;b_max); int n; //正整数 N scanf(&quot;%d&quot;,&amp;n); int i,a1,b1,a2,b2,a_n=0,b_n=0; //a1,b1,a2,b2 甲喊 甲划 乙喊 乙划 a_n=0,b_n=0 甲喝 乙喝 for(i=0;i&lt;n;i++) &#123; //两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 scanf(&quot;%d %d %d %d&quot;,&amp;a1,&amp;a2,&amp;b1,&amp;b2); if(a2==a1+b1&amp;&amp;b2!=a1+b1)&#123; //甲输了，那么甲就要喝 a_n++; &#125; if(b2==a1+b1&amp;&amp;a2!=a1+b1)&#123; //乙输了，那么乙就要喝 b_n++; &#125; if(a_n==a_max+1||b_n==b_max+1)&#123; //两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 break; &#125; &#125; if(a_n==a_max+1) &#123; //说明甲喝的已经超过自己的酒量了，甲就输了 printf(&quot;A\\n&quot;); printf(&quot;%d&quot;,b_n); &#125; else &#123; //说明乙喝的已经超过自己的酒量了，乙就输了 printf(&quot;B\\n&quot;); printf(&quot;%d&quot;,a_n); &#125;&#125; PTA-天梯赛——L1-020 帅到没朋友 当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。 输入格式： 输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。 注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。 输出格式： 按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出 No one is handsome。 注意：同一个人可以被查询多次，但只输出一次。 输入样例1： 12345633 11111 22222 555552 33333 444444 55555 66666 99999 77777855555 44444 10000 88888 22222 11111 23333 88888 输出样例1： 110000 88888 23333 输入样例2： 12345633 11111 22222 555552 33333 444444 55555 66666 99999 77777455555 44444 22222 11111 输出样例2： 1No one is handsome 解法1（C） 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;int fri[100000] = &#123;0&#125;; //下标即id，1为有朋友，0为没朋友，初始默认都没朋友 int main() &#123; int N; scanf(&quot;%d&quot;, &amp;N); for(int i = 0; i &lt; N; i++) &#123; int k; scanf(&quot;%d&quot;, &amp;k); //第i+1个朋友圈里的人数 int id[k]; for(int j = 0; j &lt; k; j++) &#123; scanf(&quot;%d&quot;, &amp;id[j]); if(k != 1) &#123;fri[id[j]] = 1;&#125; //该朋友圈里的所有id都有朋友 &#125; &#125; int M; scanf(&quot;%d&quot;, &amp;M); int search[M], flag1 = 0, n = 1; //flag1表示有无很帅的人,0表示没有 for(int i = 0; i &lt; M; i++) scanf(&quot;%d&quot;, &amp;search[i]); for(int i = 0; i &lt; M; i++) &#123; if(fri[search[i]] == 0) &#123; --n; flag1 = 1; fri[search[i]] = 1; //已经查询过的id改为有朋友避免再次查询 if(n != 0) &#123;printf(&quot; &quot;);&#125; printf(&quot;%05d&quot;, search[i]); &#125; &#125; if(flag1 == 0) &#123;printf(&quot;No one is handsome&quot;);&#125;&#125; 解法2（C++） 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,m,a[100001]=&#123;0&#125;,t,b[10001],k=0; cin&gt;&gt;n; for(;n--;) &#123; cin&gt;&gt;m; for(int l=0;l&lt;m;l++) &#123; cin&gt;&gt;t; if(m!=1)//防止自恋狂多次加朋友圈 a[t]++; &#125; &#125; cin&gt;&gt;n; for(;n--;) &#123; cin&gt;&gt;t; if(a[t]==0) &#123; b[k++]=t; a[t]=1; &#125; &#125; for(n=0;n&lt;k;n++) &#123; printf(&quot;%05d&quot;,b[n]); if(n!=k-1) cout&lt;&lt;&quot; &quot;; &#125; if(!k) cout&lt;&lt;&quot;No one is handsome\\n&quot;;&#125; 解法3（C++中的set） 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; find_s, search_s;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int k; cin &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; int x; cin &gt;&gt; x; if (k &gt; 1) find_s.insert(x); &#125; &#125; int m; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int x; cin &gt;&gt; x; if (!find_s.count(x) &amp;&amp; !search_s.count(x)) &#123; if (search_s.size()) cout &lt;&lt; &#x27; &#x27;; search_s.insert(x); printf(&quot;%05d&quot;, x); &#125; &#125; if (!search_s.size()) printf(&quot;No one is handsome&quot;); puts(&quot;&quot;); return 0;&#125; PTA-天梯赛——L1-022 奇偶分家 给定N个正整数，请统计奇数和偶数各有多少个？ 输入格式： 输入第一行给出一个正整N（≤1000）；第2行给出N个非负整数，以空格分隔。 输出格式： 在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。 输入样例： 12988 74 101 26 15 0 34 22 77 输出样例： 13 6 我的解法 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int N; int odd=0,even=0; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; int k; cin &gt;&gt; k; if(k%2 != 0)&#123; odd+=1; &#125; else&#123; even+=1; &#125; &#125; cout&lt;&lt;odd&lt;&lt;&quot; &quot;&lt;&lt;even; return 0;&#125; PTA-天梯赛——L1-023 输出GPLT 给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按GPLTGPLT....这样的顺序输出，并忽略其它字符。当然，四种字符（不区分大小写）的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按GPLT的顺序打印，直到所有字符都被输出。 输入格式： 输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。 输出格式： 在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例： 1pcTclnGloRgLrtLhgljkLhGFauPewSKgt 输出样例： 1GPLTGPLTGLTGLGLL 解法1 12345678910111213141516171819202122232425262728293031323334353637383940//这也是一道简单的分支循环题#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[10050]; int arr[4]=&#123;0,0,0,0&#125;; scanf(&quot;%s&quot;,s); int len = strlen(s); for(int i=0;i&lt;len;i++) &#123; if(s[i] == &#x27;G&#x27;||s[i] == &#x27;g&#x27;) arr[0]++; if(s[i] == &#x27;P&#x27;||s[i] == &#x27;p&#x27;) arr[1]++; if(s[i] == &#x27;L&#x27;||s[i] == &#x27;l&#x27;) arr[2]++; if(s[i] == &#x27;T&#x27;||s[i] == &#x27;t&#x27;) arr[3]++; &#125; while(arr[0]+arr[1]+arr[2]+arr[3]) &#123; if(arr[0]&gt;0) &#123; printf(&quot;G&quot;); arr[0]--; &#125; if(arr[1]&gt;0) &#123; printf(&quot;P&quot;); arr[1]--; &#125; if(arr[2]&gt;0) &#123; printf(&quot;L&quot;); arr[2]--; &#125; if(arr[3]&gt;0) &#123; printf(&quot;T&quot;); arr[3]--; &#125; &#125;&#125; 解法2 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main()&#123; char ch; int g=0,p=0,l=0,t=0; while((ch=getchar()) != &#x27;\\n&#x27;) &#123; ch=toupper(ch); if(ch == &#x27;G&#x27;) g++; else if(ch == &#x27;P&#x27;) p++; else if(ch == &#x27;L&#x27;) l++; else if(ch == &#x27;T&#x27;) t++; &#125; while(g || p || l || t) &#123; if(g) &#123;putchar(&#x27;G&#x27;); g--;&#125; if(p) &#123;putchar(&#x27;P&#x27;); p--;&#125; if(l) &#123;putchar(&#x27;L&#x27;); l--;&#125; if(t) &#123;putchar(&#x27;T&#x27;); t--;&#125; &#125; return 0;&#125; PTA-天梯赛——L1-027 出租 下面是新浪微博上曾经很火的一张图： 一时间网上一片求救声，急问这个怎么破。其实这段代码很简单，index数组就是arr数组的下标，index[0]=2 对应 arr[2]=1，index[1]=0 对应 arr[0]=8，index[2]=3 对应 arr[3]=0，以此类推…… 很容易得到电话号码是18013820100。 本题要求你编写一个程序，为任何一个电话号码生成这段代码 —— 事实上，只要生成最前面两行就可以了，后面内容是不变的。 输入格式： 输入在一行中给出一个由11位数字组成的手机号码。 输出格式： 为输入的号码生成代码的前两行，其中arr中的数字必须按递减顺序给出。 输入样例： 118013820100 输出样例： 12int[] arr = new int[]&#123;8,3,2,1,0&#125;;int[] index = new int[]&#123;3,0,4,3,1,0,2,4,3,4,4&#125;; 我的解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt; using namespace std; vector&lt;int&gt;v; // 用 map 容器存储 arr 序列的值和下标map&lt;int, int&gt;mp; int main()&#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i++) &#123; v.push_back(s[i] - &#x27;0&#x27;); &#125; // unique 将 vector 中需重复的移道前面，返回不重复最后一个下标// 绕后用 vector 中的 erase 删除重复部分 sort(v.begin(), v.end(), greater&lt;int&gt;()); v.erase(unique(v.begin(), v.end()), v.end()); // 输出去重后按降序排列的 arr 序列 printf(&quot;int[] arr = new int[]&#123;%d&quot;, v[0]); for (int i = 1; i &lt; v.size(); i++) &#123; printf(&quot;,%d&quot;, v[i]); &#125; printf(&quot;&#125;;&quot;); // 输出号码在 arr 序列中的下标 for (int i = 0; i &lt; v.size(); i++) &#123; mp[v[i]] = i; &#125; printf(&quot;\\nint[] index = new int[]&#123;&quot;); for (int i = 0; i &lt; s.size(); i++) &#123; if (i) cout &lt;&lt; &#x27;,&#x27;; cout &lt;&lt; mp[s[i] - &#x27;0&#x27;]; &#125; printf(&quot;&#125;;&quot;); return 0;&#125; PTA-天梯赛——L1-036 A乘以B 看我没骗你吧 —— 这是一道你可以在 10 秒内完成的题：给定两个绝对值不超过 100 的整数 A 和 B，输出 A 乘以 B 的值。 输入格式： 输入在第一行给出两个整数 A 和 B（−100≤A,B≤100），数字间以空格分隔。 输出格式： 在一行中输出 A 乘以 B 的值。 输入样例： 1-8 13 输出样例： 1-104 我的解法： 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int m,n; cin&gt;&gt;m&gt;&gt;n; if((m&gt;=-100)&amp;&amp;(m&lt;=100)&amp;&amp;(n&gt;=-100)&amp;&amp;(n&lt;=100))&#123; cout&lt;&lt;m*n; &#125; return 0; &#125; PTA-天梯赛——L1-038 新世界 这道超级简单的题目没有任何输入。 你只需要在第一行中输出程序员钦定名言“Hello World”，并且在第二行中输出更新版的“Hello New World”就可以了。 输入样例： 1无 输出样例： 12Hello WorldHello New World 我的解法： 12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;Hello World&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Hello New World&quot;; return 0; &#125; PTA-天梯赛——L1-052 2018我们要赢 2018年天梯赛的注册邀请码是“2018wmyy”，意思就是“2018我们要赢”。本题就请你用汉语拼音输出这句话。 输入格式： 本题没有输入。 输出格式： 在第一行中输出：“2018”；第二行中输出：“wo3 men2 yao4 ying2 !”。 输入样例： 1无 输出样例： 122018wo3 men2 yao4 ying2 ! 我的解法： 123456789#include &lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;2018&quot;&lt;&lt;endl; cout&lt;&lt;&quot;wo3 men2 yao4 ying2 !&quot;; return 0; &#125; PTA-天梯赛——L1-057 PTA使我精神焕发 输入格式： 本题没有输入。 输出格式： 在一行中按照样例输出，以惊叹号结尾。 输入样例： 1无 输出样例： 1PTA shi3 wo3 jing1 shen2 huan4 fa1 ! 我的解法： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;PTA shi3 wo3 jing1 shen2 huan4 fa1 !&quot;; return 0; &#125; PTA-天梯赛——L1-065 嫑废话上代码 Linux 之父 Linus Torvalds 的名言是：“Talk is cheap. Show me the code.”（嫑废话，上代码）。本题就请你直接在屏幕上输出这句话。 输入格式： 本题没有输入。 输出格式： 在一行中输出 Talk is cheap. Show me the code.。 输入样例： 1无 输出样例： 1Talk is cheap. Show me the code. 我的解法： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;Talk is cheap. Show me the code.&quot;; return 0; &#125; PTA-天梯赛——L1-066 猫是液体 测量一个人的体积是很难的，但猫就不一样了。因为猫是液体，所以可以很容易地通过测量一个长方体容器的容积来得到容器里猫的体积。本题就请你完成这个计算。 输入格式： 输入在第一行中给出 3 个不超过 100 的正整数，分别对应容器的长、宽、高。 输出格式： 在一行中输出猫的体积。 输入样例： 123 15 20 输出样例： 16900 我的解法： 123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if((x&gt;0)&amp;&amp;(x&lt;=100)&amp;&amp;(y&gt;0)&amp;&amp;(y&lt;=100)&amp;&amp;(z&gt;0)&amp;&amp;(z&lt;=100))&#123; cout&lt;&lt;x*y*z; &#125; return 0; &#125; PTA-天梯赛——L1-073 人与神 跨界大神 L. Peter Deutsch 有一句名言：“To iterate is human, to recurse divine.”（迭代的是人，递归的是神）。本题就请你直接在屏幕上输出这句话。 输入格式： 本题没有输入。 输出格式： 在一行中输出 To iterate is human, to recurse divine.。 输入样例： 1无 输出样例： 1To iterate is human, to recurse divine. 我的解法： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;To iterate is human, to recurse divine.&quot;; return 0; &#125; PTA-天梯赛——L1-074 两小时学完C语言 知乎上有个宝宝问：“两个小时内如何学完 C 语言？”当然，问的是“学完”并不是“学会”。 假设一本 C 语言教科书有 N 个字，这个宝宝每分钟能看 K 个字，看了 M 分钟。还剩多少字没有看？ 输入格式： 输入在一行中给出 3 个正整数，分别是 N（不超过 400 000），教科书的总字数；K（不超过 3 000），是宝宝每分钟能看的字数；M（不超过 120），是宝宝看书的分钟数。 题目保证宝宝看完的字数不超过 N。 输出格式： 在一行中输出宝宝还没有看的字数。 输入样例： 1100000 1000 72 输出样例： 128000 我的解法： 12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int N,K,M; cin&gt;&gt;N&gt;&gt;K&gt;&gt;M; if(N&gt;=K*M)&#123; cout&lt;&lt;N-(K*M); &#125; return 0; &#125; PTA-天梯赛——L1-082 种钻石 2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗 1 克拉大小的钻石。 本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。 输入格式： 输入在一行中给出钻石的需求量 N（不超过 1000000的正整数，以微克拉为单位）和人工培育钻石的速度 v（1≤v≤200，以微克拉/天为单位的整数）。 输出格式： 在一行中输出培育 N 微克拉钻石需要的整数天数。不到一天的时间不算在内。 输入样例： 1102000 130 输出样例： 1784 我的解法： 1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; int N,v; cin&gt;&gt;N&gt;&gt;v; cout&lt;&lt;N/v; return 0; &#125; PTA-天梯赛——L1-084 拯救外星人 你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 N 的阶乘记为 “N!”，是从 1 到 N 的连乘积。所以当他不知道“5+7”等于多少时，如果你告诉他等于“12!”，他就写出了“479001600”这个答案。 本题就请你写程序模仿外星人的行为。 输入格式： 输入在一行中给出两个正整数 A 和 B。 输出格式： 在一行中输出 (A+B) 的阶乘。题目保证 (A+B) 的值小于 12。 输入样例： 13 6 输出样例： 1362880 我的解法： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int JieCheng(int x)&#123; if(x&gt;=0)&#123; if(x&gt;0)&#123; return (x*JieCheng(x-1)); &#125; else&#123; return 1; &#125; &#125;&#125;int main() &#123; int A,B; cin&gt;&gt;A&gt;&gt;B; if(A+B &lt;12)&#123; cout&lt;&lt;JieCheng(A+B); &#125; return 0; &#125; PTA-天梯赛——L1-053 电子汪 据说汪星人的智商能达到人类 4 岁儿童的水平，更有些聪明汪会做加法计算。比如你在地上放两堆小球，分别有 1 只球和 2 只球，聪明汪就会用“汪！汪！汪！”表示 1 加 2 的结果是 3。 本题要求你为电子宠物汪做一个模拟程序，根据电子眼识别出的两堆小球的个数，计算出和，并且用汪星人的叫声给出答案。 输入格式： 输入在一行中给出两个 [1, 9] 区间内的正整数 A 和 B，用空格分隔。 输出格式： 在一行中输出 A + B 个Wang!。 输入样例： 12 1 输出样例： 1Wang!Wang!Wang! 我的解法： 12345678910111213141516#include &lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main() &#123; int A,B; cin&gt;&gt;A&gt;&gt;B; string wang = &quot;Wang!&quot;; if(A&gt;=1 &amp;&amp; A&lt;=9 &amp;&amp; B&gt;=1 &amp;&amp; B&lt;=9)&#123; for(int i=1;i&lt;=(A+B);i++)&#123; cout&lt;&lt;wang; &#125; &#125; return 0; &#125; PTA-天梯赛——L1-085 试试手气 们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件： 1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同； 2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。 那么你应该可以预知自己第 n 次（1≤n≤5）摇出的结果。 输入格式： 输入第一行给出 6 个骰子的初始点数，即 [1,6] 之间的整数，数字间以空格分隔；第二行给出摇的次数 n（1≤n≤5）。 输出格式： 在一行中顺序列出第 n 次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。 输入样例： 123 6 5 4 1 43 输出样例： 14 3 3 3 4 3 样例解释 ： 这 3 次摇出的结果依次为： 1236 5 6 6 6 65 4 4 5 5 54 3 3 3 4 3 我的解法（网上找的，感觉很强）： 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main()&#123; int a[10]; for(int i=1;i&lt;=6;i++) cin&gt;&gt;a[i]; int n; cin&gt;&gt;n; for(int i=1;i&lt;=6;i++) &#123; if(i!=1) cout&lt;&lt;&#x27; &#x27;; if(a[i]&gt;6-n) cout&lt;&lt;6-n; else cout&lt;&lt;7-n; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"C++中STL用法超详细总结","slug":"C-中STL用法超详细总结","date":"2022-09-23T01:32:00.000Z","updated":"2022-09-23T01:54:08.324Z","comments":true,"path":"2022/09/23/C-中STL用法超详细总结/","link":"","permalink":"http://example.com/2022/09/23/C-%E4%B8%ADSTL%E7%94%A8%E6%B3%95%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/","excerpt":"1 什么是STL？ STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组； STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效； 从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术； 从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。","text":"1 什么是STL？ STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组； STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效； 从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术； 从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。 2 STL内容介绍 STL中六大组件： 容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器； 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义operator*()以及其他类似于指针的操作符地方法的类对象； 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用； 仿函数（Functor） 适配器（Adaptor） 分配器（allocator） 2.1 容器 STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。 （1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list； Vector：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时； ​ Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时； deque 和 vector 的最大差异一在于 deque 允许常数时间内对头端或尾端进行元素的插入或移除操作。 vector的开销太大，需要开辟新空间，拷贝。 deque 没有所谓的容量概念，因为它是动态地以分段连续空间组合而成随时可以增加一块新的空间并拼接起来。 虽然 deque 也提供 随机访问的迭代器，但它的迭代器和前面两种容器的都不一样，其设计相当复杂度和精妙，因此，会对各种运算产生一定影响，除非必要，尽可能的选择使用 vector 而非 deque。 ​ List：由于链表的存储方式并不是连续的内存空间，因此链表list的迭代器，只支持前移和后移，属于双向迭代器，不能跳跃式访问。双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；缺点：对内存空间的耗费较大 （2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。 Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找； Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器类自动申请和释放内存，无需new和delete操作。 2.2 STL迭代器 Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator. 2.3 算法 函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。 STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。 算法部分主要由头文件，和组成。 是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 中则定义了一些模板类，用以声明函数对象。 STL中算法大致分为四类： 非可变序列算法：指不直接修改其所操作的容器内容的算法。 可变序列算法：指可以修改它们所操作的容器内容的算法。 排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 数值算法：对容器内容进行数值计算。 以下对所有算法进行细致分类并标明功能： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值 adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 find_end: 在指定范围内查找&quot;由输入的另外一对iterator标志的第二个序列&quot;的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的&quot;另外一对&quot;的第一个ForwardIterator。重载版本使用用户输入的操作符代 替等于操作。 find_first_of: 在指定范围内查找&quot;由输入的另外一对iterator标志的第二个序列&quot;中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略 inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重 载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个) copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合 next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个) accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个) fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一 个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个) equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个) set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个) make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被&quot;弹出&quot;的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。 2.4 仿函数 2.4.1 概述 ​ 仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。 有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。 1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。 2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。 2.4.2 仿函数(functor)在编程语言中的应用 1）C语言使用函数指针和回调函数来实现仿函数，例如一个用来排序的函数可以这样使用仿函数 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//int sort_function( const void *a, const void *b);int sort_function( const void *a, const void *b)&#123; return *(int*)a-*(int*)b;&#125; int main()&#123; int list[5] = &#123; 54, 21, 11, 67, 22 &#125;; qsort((void *)list, 5, sizeof(list[0]), sort_function);//起始地址，个数，元素大小，回调函数 int x; for (x = 0; x &lt; 5; x++) printf(&quot;%i\\n&quot;, list[x]); return 0;&#125; 2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;template&lt;typename T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; for_each(ia, ia + 5, display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 2.4.3 仿函数在STL中的定义 要使用STL内建的仿函数，必须包含头文件。而头文件中包含的仿函数分类包括 1）算术类仿函数 加：plus&lt;T&gt; 减：minus&lt;T&gt; 乘：multiplies&lt;T&gt; 除：divides&lt;T&gt; 模取：modulus&lt;T&gt; 否定：negate&lt;T&gt; 例子： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;vector&gt; #include &lt;functional&gt; using namespace std; int main()&#123; int ia[] = &#123; 1,2,3,4,5 &#125;; vector&lt;int&gt; iv(ia, ia + 5); //120 cout &lt;&lt; accumulate(iv.begin(), iv.end(), 1, multiplies&lt;int&gt;()) &lt;&lt; endl; //15 cout &lt;&lt; multiplies&lt;int&gt;()(3, 5) &lt;&lt; endl; modulus&lt;int&gt; modulusObj; cout &lt;&lt; modulusObj(3, 5) &lt;&lt; endl; // 3 system(&quot;pause&quot;); return 0;&#125; 2）关系运算类仿函数 等于：equal_to&lt;T&gt; 不等于：not_equal_to&lt;T&gt; 大于：greater&lt;T&gt; 大于等于：greater_equal&lt;T&gt; 小于：less&lt;T&gt; 小于等于：less_equal&lt;T&gt; 从大到小排序： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;#include&lt;functional&gt;#include &lt;vector&gt; using namespace std; template &lt;class T&gt;class display&#123;public: void operator()(const T &amp;x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125;;int main()&#123; int ia[] = &#123; 1,5,4,3,2 &#125;; vector&lt;int&gt; iv(ia, ia + 5); sort(iv.begin(), iv.end(), greater&lt;int&gt;()); for_each(iv.begin(), iv.end(), display&lt;int&gt;()); system(&quot;pause&quot;); return 0;&#125; 3）逻辑运算仿函数 逻辑与：logical_and&lt;T&gt; 逻辑或：logical_or&lt;T&gt; 逻辑否：logical_no&lt;T&gt; 除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结 2.5 容器适配器 标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈) 什么是容器适配器 ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例如，stack&lt;int, vector &gt;实现了栈的功能，但其内部使用顺序容器vector来存储数据。（相当于是vector表现出了栈的行为）。 容器适配器 要使用适配器，需要加入一下头文件： #include &lt;stack&gt; //stack #include&lt;queue&gt; //queue、priority_queue 种类 默认顺序容器 可用顺序容器 说明 stack deque vector、list、deque queue deque list、deque 基础容器必须提供push_front()运算 priority_queue vector vector、deque 基础容器必须提供随机访问功能 定义适配器 1、初始化 ​ stack stk(dep); 2、覆盖默认容器类型 ​ stack&lt;int,vector &gt; stk; 使用适配器 2.5.1 stack 1234567stack&lt;int&gt; s;stack&lt; int, vector&lt;int&gt; &gt; stk; //覆盖基础容器类型，使用vector实现stks.empty(); //判断stack是否为空，为空返回true，否则返回falses.size(); //返回stack中元素的个数s.pop(); //删除栈顶元素，但不返回其值s.top(); //返回栈顶元素的值，但不删除此元素s.push(item); //在栈顶压入新元素item 实例：括号匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;int main()&#123; string s; stack&lt;char&gt; ss; while (cin &gt;&gt; s) &#123; bool flag = true; for (char c : s) //C++11新标准，即遍历一次字符串s &#123; if (c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27;) &#123; ss.push(c); continue; &#125; if (c == &#x27;&#125;&#x27;) &#123; if (!ss.empty() &amp;&amp; ss.top() == &#x27;&#123;&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;]&#x27;) &#123; if (ss.top() == &#x27;[&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; if (!ss.empty() &amp;&amp; c == &#x27;)&#x27;) &#123; if (ss.top() == &#x27;(&#x27;) &#123; ss.pop(); continue; &#125; else &#123; flag = false; break; &#125; &#125; &#125; if (flag) cout &lt;&lt; &quot;Match!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Not Match!&quot; &lt;&lt; endl; &#125;&#125; 2.5.2 queue &amp; priority_queue 123456789101112queue&lt;int&gt; q; //priority_queue&lt;int&gt; q;q.empty(); //判断队列是否为空q.size(); //返回队列长度q.push(item); //对于queue，在队尾压入一个新元素 //对于priority_queue，在基于优先级的适当位置插入新元素 //queue only:q.front(); //返回队首元素的值，但不删除该元素q.back(); //返回队尾元素的值，但不删除该元素 //priority_queue only:q.top(); //返回具有最高优先级的元素值，但不删除该元素 3 常用容器用法介绍 3.1 vector 3.1.1 基本函数实现 1.构造函数 vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector&amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 void push_back(const T&amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 int size() const:返回向量中元素的个数 int capacity() const:返回当前向量张红所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数 void swap(vector&amp;):交换两个同类型向量的数据 void assign(int n,const T&amp; x):设置向量中第n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 8.看着清楚 1.push_back 在数组的最后添加一个数据 2.pop_back 去掉数组的最后一个数据 3.at 得到编号位置的数据 4.begin 得到数组头的指针 5.end 得到数组的最后一个单元+1的指针 6．front 得到数组头的引用 7.back 得到数组的最后一个单元的引用 8.max_size 得到vector最大可以是多大 9.capacity 当前vector分配的大小 10.size 当前使用数据的大小 11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 12.reserve 改变当前vecotr所分配空间的大小 13.erase 删除指针指向的数据项 14.clear 清空当前的vector 15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) 16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1) 17.empty 判断vector是否为空 18.swap 与另一个vector交换数据 3.1.2 基本用法 12#include &lt; vector&gt; using namespace std; 3.1.3 简单介绍 Vector&lt;类型&gt;标识符 Vector&lt;类型&gt;标识符(最大容量) Vector&lt;类型&gt;标识符(最大容量,初始所有值) Int i[5]={1,2,3,4,5} Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值 Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过 3.1.4 实例 3.1.4.1 pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据 12345678910111213141516171819202122232425262728#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std; int main()&#123; vector&lt;int&gt;obj;//创建一个向量存储容器 int for(int i=0;i&lt;10;i++) // push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; for(int i=0;i&lt;5;i++)//去掉数组最后一个数据 &#123; obj.pop_back(); &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++)//size()容器中实际数据个数 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 1230,1,2,3,4,5,6,7,8,9, 0,1,2,3,4, 3.1.4.2 clear()清除容器中所有数据 12345678910111213141516171819202122#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std; int main()&#123; vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++)//push_back(elem)在数组最后添加数据 &#123; obj.push_back(i); cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; obj.clear();//清除容器中所以数据 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;endl; &#125; return 0;&#125; 输出结果为： 10,1,2,3,4,5,6,7,8,9, 3.1.4.3 排序 1234567891011121314151617181920212223242526272829303132#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; vector&lt;int&gt;obj; obj.push_back(1); obj.push_back(3); obj.push_back(0); sort(obj.begin(),obj.end());//从小到大 cout&lt;&lt;&quot;从小到大:&quot;&lt;&lt;endl; for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; cout&lt;&lt;&quot;\\n&quot;&lt;&lt;endl; cout&lt;&lt;&quot;从大到小:&quot;&lt;&lt;endl; reverse(obj.begin(),obj.end());//从大到小 for(int i=0;i&lt;obj.size();i++) &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot;,&quot;; &#125; return 0;&#125; 输出结果为： 12345从小到大:0,1,3, 从大到小:3,1,0, 1.注意 sort 需要头文件 #include 2.如果想 sort 来降序，可重写 sort 12345678bool compare(int a,int b) &#123; return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序 &#125; int a[20]=&#123;2,4,1,23,5,76,0,43,24,65&#125;,i; for(i=0;i&lt;20;i++) cout&lt;&lt; a[i]&lt;&lt; endl; sort(a,a+20,compare); 3.1.4.4 访问（直接数组访问&amp;迭代器访问） 12345678910111213141516171819202122232425262728293031#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; //顺序访问 vector&lt;int&gt;obj; for(int i=0;i&lt;10;i++) &#123; obj.push_back(i); &#125; cout&lt;&lt;&quot;直接利用数组：&quot;; for(int i=0;i&lt;10;i++)//方法一 &#123; cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;利用迭代器：&quot; ; //方法二，使用迭代器将容器中数据输出 vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 for(it=obj.begin();it!=obj.end();it++) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 输出结果为： 12直接利用数组：0 1 2 3 4 5 6 7 8 9 利用迭代器：0 1 2 3 4 5 6 7 8 9 3.1.4.5 二维数组两种定义方法（结果一样） 方法一 1234567891011121314151617181920212223242526#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N); //定义二维动态数组大小5行 for(int i =0; i&lt; obj.size(); i++)//动态二维数组为5行6列，值全为0 &#123; obj[i].resize(M); &#125; for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 方法二 12345678910111213141516171819202122#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125; 输出结果为： 123450 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3.2 deque 所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。 3.2.1 声明deque容器 123456#include&lt;deque&gt; // 头文件deque&lt;type&gt; deq; // 声明一个元素类型为type的双端队列quedeque&lt;type&gt; deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque&lt;type&gt; deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque&lt;type&gt; deq(mydeque); // deq是mydeque的一个副本deque&lt;type&gt; deq(first, last); // 使用迭代器first、last范围内的元素初始化deq 3.2.2 deque的常用成员函数 1deque&lt;int&gt; deq; deq[ ]：用来访问双向队列中单个的元素。 deq.front()：返回第一个元素的引用。 deq.back()：返回最后一个元素的引用。 deq.push_front(x)：把元素x插入到双向队列的头部。 deq.pop_front()：弹出双向队列的第一个元素。 deq.push_back(x)：把元素x插入到双向队列的尾部。 deq.pop_back()：弹出双向队列的最后一个元素。 3.2.3 deque的一些特点 支持随机访问，即支持[ ]以及at()，但是性能没有vector好。 可以在内部进行插入和删除操作，但性能不及list。 deque两端都能够快速插入和删除元素，而vector只能在尾端进行。 deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。 deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。 deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。 deque不支持对容量和内存分配时机的控制。 在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。 deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。 deque不提供容量操作：capacity()和reverse()，但是vector可以。 3.2.4 实例 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;deque&gt;using namespace std;int main(void)&#123; int i; int a[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;; deque&lt;int&gt; q; for (i = 0; i &lt;= 9; i++) &#123; if (i % 2 == 0) q.push_front(a[i]); else q.push_back(a[i]); &#125; /*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/ q.pop_front(); printf(&quot;%d\\n&quot;, q.front()); /*清除第一个元素后输出第一个(6)*/ q.pop_back(); printf(&quot;%d\\n&quot;, q.back()); /*清除最后一个元素后输出最后一个(7)*/ deque&lt;int&gt;::iterator it; for (it = q.begin(); it != q.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &#x27;\\t&#x27;; &#125; cout &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 输出结果： 123676 4 2 0 1 3 5 7 3.3 list 3.3.1 list定义 List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件 #include 3.3.2 list定义和初始化 list&lt;int&gt;lst1; //创建空list list&lt;int&gt; lst2(5); //创建含有5个元素的list list&lt;int&gt;lst3(3,2); //创建含有3个元素的list list&lt;int&gt;lst4(lst2); //使用lst2初始化lst4 list&lt;int&gt;lst5(lst2.begin(),lst2.end()); //同lst4 3.3.3 list常用操作函数 Lst1.assign() 给list赋值 Lst1.back() 返回最后一个元素 Lst1.begin() 返回指向第一个元素的迭代器 Lst1.clear() 删除所有元素 Lst1.empty() 如果list是空的则返回true Lst1.end() 返回末尾的迭代器 Lst1.erase() 删除一个元素 Lst1.front() 返回第一个元素 Lst1.get_allocator() 返回list的配置器 Lst1.insert() 插入一个元素到list中 Lst1.max_size() 返回list能容纳的最大元素数量 Lst1.merge() 合并两个list Lst1.pop_back() 删除最后一个元素 Lst1.pop_front() 删除第一个元素 Lst1.push_back() 在list的末尾添加一个元素 Lst1.push_front() 在list的头部添加一个元素 Lst1.rbegin() 返回指向第一个元素的逆向迭代器 Lst1.remove() 从list删除元素 Lst1.remove_if() 按指定条件删除元素 Lst1.rend() 指向list末尾的逆向迭代器 Lst1.resize() 改变list的大小 Lst1.reverse() 把list的元素倒转 Lst1.size() 返回list中的元素个数 Lst1.sort() 给list排序 Lst1.splice() 合并两个list Lst1.swap() 交换两个list Lst1.unique() 删除list中相邻重复的元素 3.3.4 List使用实例 3.3.4.1 迭代器遍历list 12345for(list&lt;int&gt;::const_iteratoriter = lst1.begin();iter != lst1.end();iter++) &#123; cout&lt;&lt;*iter; &#125; cout&lt;&lt;endl; 3.3.4.2 综合实例1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;numeric&gt;#include &lt;algorithm&gt;using namespace std; typedef list&lt;int&gt; LISTINT;typedef list&lt;int&gt; LISTCHAR; void main()&#123; //用LISTINT创建一个list对象 LISTINT listOne; //声明i为迭代器 LISTINT::iterator i; listOne.push_front(3); listOne.push_front(2); listOne.push_front(1); listOne.push_back(4); listOne.push_back(5); listOne.push_back(6); cout &lt;&lt; &quot;listOne.begin()--- listOne.end():&quot; &lt;&lt; endl; for (i = listOne.begin(); i != listOne.end(); ++i) cout &lt;&lt; *i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; LISTINT::reverse_iterator ir; cout &lt;&lt; &quot;listOne.rbegin()---listOne.rend():&quot; &lt;&lt; endl; for (ir = listOne.rbegin(); ir != listOne.rend(); ir++) &#123; cout &lt;&lt; *ir &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; int result = accumulate(listOne.begin(), listOne.end(), 0); cout &lt;&lt; &quot;Sum=&quot; &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl; //用LISTCHAR创建一个list对象 LISTCHAR listTwo; //声明i为迭代器 LISTCHAR::iterator j; listTwo.push_front(&#x27;C&#x27;); listTwo.push_front(&#x27;B&#x27;); listTwo.push_front(&#x27;A&#x27;); listTwo.push_back(&#x27;D&#x27;); listTwo.push_back(&#x27;E&#x27;); listTwo.push_back(&#x27;F&#x27;); cout &lt;&lt; &quot;listTwo.begin()---listTwo.end():&quot; &lt;&lt; endl; for (j = listTwo.begin(); j != listTwo.end(); ++j) cout &lt;&lt; char(*j) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; j = max_element(listTwo.begin(), listTwo.end()); cout &lt;&lt; &quot;The maximum element in listTwo is: &quot; &lt;&lt; char(*j) &lt;&lt; endl; system(&quot;pause&quot;);&#125; 输出结果: 3.3.4.3 综合实例2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt; #include &lt;list&gt; using namespace std;typedef list&lt;int&gt; INTLIST; //从前向后显示list队列的全部元素 void put_list(INTLIST list, char *name)&#123; INTLIST::iterator plist; cout &lt;&lt; &quot;The contents of &quot; &lt;&lt; name &lt;&lt; &quot; : &quot;; for (plist = list.begin(); plist != list.end(); plist++) cout &lt;&lt; *plist &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; //测试list容器的功能 void main(void)&#123; //list1对象初始为空 INTLIST list1; INTLIST list2(5, 1); INTLIST list3(list2.begin(), --list2.end()); //声明一个名为i的双向迭代器 INTLIST::iterator i; put_list(list1, &quot;list1&quot;); put_list(list2, &quot;list2&quot;); put_list(list3, &quot;list3&quot;); list1.push_back(7); list1.push_back(8); cout &lt;&lt; &quot;list1.push_back(7) and list1.push_back(8):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.push_front(6); list1.push_front(5); cout &lt;&lt; &quot;list1.push_front(6) and list1.push_front(5):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.insert(++list1.begin(), 3, 9); cout &lt;&lt; &quot;list1.insert(list1.begin()+1,3,9):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); //测试引用类函数 cout &lt;&lt; &quot;list1.front()=&quot; &lt;&lt; list1.front() &lt;&lt; endl; cout &lt;&lt; &quot;list1.back()=&quot; &lt;&lt; list1.back() &lt;&lt; endl; list1.pop_front(); list1.pop_back(); cout &lt;&lt; &quot;list1.pop_front() and list1.pop_back():&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list1.erase(++list1.begin()); cout &lt;&lt; &quot;list1.erase(++list1.begin()):&quot; &lt;&lt; endl; put_list(list1, &quot;list1&quot;); list2.assign(8, 1); cout &lt;&lt; &quot;list2.assign(8,1):&quot; &lt;&lt; endl; put_list(list2, &quot;list2&quot;); cout &lt;&lt; &quot;list1.max_size(): &quot; &lt;&lt; list1.max_size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.size(): &quot; &lt;&lt; list1.size() &lt;&lt; endl; cout &lt;&lt; &quot;list1.empty(): &quot; &lt;&lt; list1.empty() &lt;&lt; endl; put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); cout &lt;&lt; &quot;list1&gt;list3: &quot; &lt;&lt; (list1 &gt; list3) &lt;&lt; endl; cout &lt;&lt; &quot;list1&lt;list3: &quot; &lt;&lt; (list1 &lt; list3) &lt;&lt; endl; list1.sort(); put_list(list1, &quot;list1&quot;); list1.splice(++list1.begin(), list3); put_list(list1, &quot;list1&quot;); put_list(list3, &quot;list3&quot;); system(&quot;pause&quot;);&#125; 输出结果： 3.4 map/multimap map和multimap都需要#include，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。 C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。 Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。 3.4.1 基本操作函数 begin() 返回指向map头部的迭代器 clear(） 删除所有元素 count() 返回指定元素出现的次数 empty() 如果map为空则返回true end() 返回指向map末尾的迭代器 equal_range() 返回特殊条目的迭代器对 erase() 删除一个元素 find() 查找一个元素 get_allocator() 返回map的配置器 insert() 插入元素 key_comp() 返回比较元素key的函数 lower_bound() 返回键值&gt;=给定元素的第一个位置 max_size() 返回可以容纳的最大元素个数 rbegin() 返回一个指向map尾部的逆向迭代器 rend() 返回一个指向map头部的逆向迭代器 size() 返回map中元素的个数 swap() 交换两个map upper_bound() 返回键值&gt;给定元素的第一个位置 value_comp() 返回比较元素value的函数 3.4.2 声明 12345678910//头文件#include&lt;map&gt; map&lt;int, string&gt; ID_Name; // 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012map&lt;int, string&gt; ID_Name = &#123; &#123; 2015, &quot;Jim&quot; &#125;, &#123; 2016, &quot;Tom&quot; &#125;, &#123; 2017, &quot;Bob&quot; &#125; &#125;; 3.4.3 迭代器 共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。 二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示： 123456789map&lt;int,int&gt;::iterator it;map&lt;int,int&gt; mmap;const map&lt;int,int&gt; const_mmap; it = mmap.begin(); //iteratormmap.cbegin(); //const_iterator const_mmap.begin(); //const_iteratorconst_mmap.cbegin(); //const_iterator 返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。 3.4.4 插入操作 3.4.4.1 用insert插入pair数据 12345678910111213141516//数据的插入--第一种：用insert函数插入pair数据 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 3.4.4.2 用insert函数插入value_type数据 1234567891011121314151617//第二种：用insert函数插入value_type数据，下面举例说明 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 3.4.4.3 用insert函数进行多个插入 insert共有4个重载函数： 1234567891011// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败pair&lt;iterator,bool&gt; insert (const value_type&amp; val); //在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排iterator insert (const_iterator position, const value_type&amp; val); // 插入多个void insert (InputIterator first, InputIterator last); //c++11开始支持，使用列表插入多个 void insert (initializer_list&lt;value_type&gt; il); 下面是具体使用示例： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;map&gt; int main()&#123; std::map&lt;char, int&gt; mymap; // 插入单个值 mymap.insert(std::pair&lt;char, int&gt;(&#x27;a&#x27;, 100)); mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 200)); //返回插入位置以及是否插入成功 std::pair&lt;std::map&lt;char, int&gt;::iterator, bool&gt; ret; ret = mymap.insert(std::pair&lt;char, int&gt;(&#x27;z&#x27;, 500)); if (ret.second == false) &#123; std::cout &lt;&lt; &quot;element &#x27;z&#x27; already existed&quot;; std::cout &lt;&lt; &quot; with a value of &quot; &lt;&lt; ret.first-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; //指定位置插入 std::map&lt;char, int&gt;::iterator it = mymap.begin(); mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;b&#x27;, 300)); //效率更高 mymap.insert(it, std::pair&lt;char, int&gt;(&#x27;c&#x27;, 400)); //效率非最高 //范围多值插入 std::map&lt;char, int&gt; anothermap; anothermap.insert(mymap.begin(), mymap.find(&#x27;c&#x27;)); // 列表形式插入 anothermap.insert(&#123; &#123; &#x27;d&#x27;, 100 &#125;, &#123;&#x27;e&#x27;, 200&#125; &#125;); return 0;&#125; 3.4.4.4 用数组方式插入数据 1234567891011121314151617//第三种：用数组方式插入数据，下面举例说明 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[2] = &quot;student_two&quot;; mapStudent[3] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明 mapStudent.insert(map&lt;int, string&gt;::value_type (1, “student_one”)); mapStudent.insert(map&lt;int, string&gt;::value_type (1, “student_two”)); 上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下 pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, “student_one”)); 我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。 下面给出完成代码，演示插入成功与否问题: 123456789101112131415161718192021222324//验证插入函数的作用效果 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_two&quot;)); if(Insert_Pair.second == true) cout&lt;&lt;&quot;Insert Successfully&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Insert Failure&quot;&lt;&lt;endl; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 大家可以用如下程序，看下用数组插入在数据覆盖上的效果: 12345678910111213141516//验证数组形式插入数据的效果 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[1] = &quot;student_two&quot;; mapStudent[2] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 3.4.5 查找、删除、交换 查找 1234// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器// 根据map的类型，返回的迭代器为 iterator 或者 const_iteratoriterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const; 删除 1234567891011// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器iterator erase( iterator pos ) // 删除一定范围内的元素，并返回一个指向下一元素的迭代器iterator erase( const_iterator first, const_iterator last ); // 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1size_t erase( const key_type&amp; key ); // 清空map，清空后的size为0void clear(); 交换 12// 就是两个map的内容互换void swap( map&amp; other ); 3.4.6 容量 123456789101112// 查询map是否为空bool empty(); // 查询map中键值对的数量size_t size(); // 查询map所能包含的最大键值对数量，和系统和应用库有关。// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了size_t max_size(); // 查询关键字为key的元素的个数，在map里结果非0即1size_t count( const Key&amp; key ) const; // 3.4.7 排序 map中的元素是自动按Key升序排序，所以不能对map用sort函数； 这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。 3.4.7.1 小于号 &lt; 重载 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std; typedef struct tagStudentinfo&#123; int niD; string strName; bool operator &lt; (tagStudentinfo const&amp; _A) const &#123; //这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序 if (niD &lt; _A.niD) return true; if (niD == _A.niD) return strName.compare(_A.strName) &lt; 0; return false; &#125;&#125;Studentinfo, *PStudentinfo; //学生信息 int main()&#123; int nSize; //用学生信息映射分数 map&lt;Studentinfo, int&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;&#125; 3.4.7.2 仿函数的应用，这个时候结构体中没有直接的小于号重载 123456789101112131415161718192021222324252627282930313233343536373839404142//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明 #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std; typedef struct tagStudentinfo&#123; int niD; string strName;&#125;Studentinfo, *PStudentinfo; //学生信息 class sort&#123;public: bool operator() (Studentinfo const &amp;_A, Studentinfo const &amp;_B) const &#123; if (_A.niD &lt; _B.niD) return true; if (_A.niD == _B.niD) return _A.strName.compare(_B.strName) &lt; 0; return false; &#125;&#125;; int main()&#123; //用学生信息映射分数 map&lt;Studentinfo, int, sort&gt;mapStudent; map&lt;Studentinfo, int&gt;::iterator iter; Studentinfo studentinfo; studentinfo.niD = 1; studentinfo.strName = &quot;student_one&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 90)); studentinfo.niD = 2; studentinfo.strName = &quot;student_two&quot;; mapStudent.insert(pair&lt;Studentinfo, int&gt;(studentinfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.niD &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;first.strName &lt;&lt; &#x27; &#x27; &lt;&lt; iter-&gt;second &lt;&lt; endl; system(&quot;pause&quot;);&#125; 3.4.8 unordered_map 在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？ map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。 unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。 还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。 最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。 至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。 3.5 set/multiset std::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。 set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。 由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。 multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。 set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。 3.5.1 set常用成员函数 begin()–返回指向第一个元素的迭代器 clear()–清除所有元素 count()–返回某个值元素的个数 empty()–如果集合为空，返回true end()–返回指向最后一个元素的迭代器 equal_range()–返回集合中与给定值相等的上下限的两个迭代器 erase()–删除集合中的元素 find()–返回一个指向被查找到元素的迭代器 get_allocator()–返回集合的分配器 insert()–在集合中插入元素 lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()–返回一个用于元素间值比较的函数 max_size()–返回集合能容纳的元素的最大限值 rbegin()–返回指向集合中最后一个元素的反向迭代器 rend()–返回指向集合中第一个元素的反向迭代器 size()–集合中元素的数目 swap()–交换两个集合变量 upper_bound()–返回大于某个值元素的迭代器 value_comp()–返回一个用于比较元素间的值的函数 3.5.2 代码示例 以下代码涉及的内容： 1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？ 2、set容器中，如何让元素类型为自定义类型？ 3、set容器的insert函数的返回值为什么类型？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std; /* 仿函数CompareSet，在test02使用 */class CompareSet&#123;public: //从大到小排序 bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125; //从小到大排序 //bool operator()(int v1, int v2) //&#123; // return v1 &lt; v2; //&#125;&#125;; /* Person类，用于test03 */class Person&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person);public: Person(string name, int age) &#123; mName = name; mAge = age; &#125;public: string mName; int mAge;&#125;; ostream &amp;operator&lt;&lt;(ostream &amp;out, const Person &amp;person)&#123; out &lt;&lt; &quot;name:&quot; &lt;&lt; person.mName &lt;&lt; &quot; age:&quot; &lt;&lt; person.mAge &lt;&lt; endl; return out;&#125; /* 仿函数ComparePerson,用于test03 */class ComparePerson&#123;public: //名字大的在前面，如果名字相同，年龄大的排前面 bool operator()(const Person &amp;p1, const Person &amp;p2) &#123; if (p1.mName == p2.mName) &#123; return p1.mAge &gt; p2.mAge; &#125; return p1.mName &gt; p2.mName; &#125;&#125;; /* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; void test01()&#123; //set容器默认从小到大排序 set&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //输出set PrintSet(s); //结果为:10 20 30 /* set的insert函数返回值为一个对组(pair)。 对组的第一个值first为set类型的迭代器： 1、若插入成功，迭代器指向该元素。 2、若插入失败，迭代器指向之前已经存在的元素 对组的第二个值seconde为bool类型： 1、若插入成功，bool值为true 2、若插入失败，bool值为false */ pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(40); if (true == ret.second) cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入成功&quot; &lt;&lt; endl; else cout &lt;&lt; *ret.first &lt;&lt; &quot; 插入失败&quot; &lt;&lt; endl;&#125; void test02()&#123; /* 如果想让set容器从大到小排序，需要给set容 器提供一个仿函数,本例的仿函数为CompareSet */ set&lt;int, CompareSet&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印set PrintSet(s); //结果为:30,20,10&#125; void test03()&#123; /* set元素类型为Person，当set元素类型为自定义类型的时候 必须给set提供一个仿函数，用于比较自定义类型的大小， 否则无法通过编译 */ set&lt;Person,ComparePerson&gt; s; s.insert(Person(&quot;John&quot;, 22)); s.insert(Person(&quot;Peter&quot;, 25)); s.insert(Person(&quot;Marry&quot;, 18)); s.insert(Person(&quot;Peter&quot;, 36)); //打印set PrintSet(s);&#125; int main(void)&#123; //test01(); //test02(); //test03(); return 0;&#125; multiset容器的insert函数返回值为什么？ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;set&gt;using namespace std; /* 打印set类型的函数模板 */template&lt;typename T&gt;void PrintSet(T &amp;s)&#123; for (T::iterator iter = s.begin(); iter != s.end(); ++iter) cout &lt;&lt; *iter &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; void test(void)&#123; multiset&lt;int&gt; s; s.insert(10); s.insert(20); s.insert(30); //打印multiset PrintSet(s); /* multiset的insert函数返回值为multiset类型的迭代器， 指向新插入的元素。multiset允许插入相同的值，因此 插入一定成功，因此不需要返回bool类型。 */ multiset&lt;int&gt;::iterator iter = s.insert(10); cout &lt;&lt; *iter &lt;&lt; endl; &#125; int main(void)&#123; test(); return 0;&#125; 3.5.3 unordered_set C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。 ​ unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用: 使用unordered_set需要包含#include&lt;unordered_set&gt;头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。 除此之外unordered_multiset也是一种可选的容器。 reference： http://www.runoob.com/w3cnote/cpp-vector-container-analysis.html https://blog.csdn.net/tianshuai1111/article/details/7687983 ​ ————Designed By 李季鸿","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}],"author":"Li Jihong"},{"title":"Vue3笔记","slug":"Vue3笔记","date":"2022-09-19T14:29:00.000Z","updated":"2022-09-19T14:43:46.121Z","comments":true,"path":"2022/09/19/Vue3笔记/","link":"","permalink":"http://example.com/2022/09/19/Vue3%E7%AC%94%E8%AE%B0/","excerpt":"Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0","text":"Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么 1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% … 2.源码的升级 使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking … 3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API（组合API） setup配置 ref与reactive watch与watchEffect provide与inject … 新的内置组件 Fragment Teleport Suspense 其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除keyCode支持作为 v-on 的修饰符 … 一、创建Vue3.0工程 1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 123456789## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve 2.使用 vite 创建 官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 12345678## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev 二、常用 Composition API 官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 1.拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 3.reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 4.Vue3.0中的响应式原理 vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 1234Object.defineProperty(data, &#x27;count&#x27;, &#123; get () &#123;&#125;, set () &#123;&#125;&#125;) 存在问题： 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect 12345678910111213141516new Proxy(data, &#123; // 拦截读取属性值 get (target, prop) &#123; return Reflect.get(target, prop) &#125;, // 拦截设置属性值或添加新属性 set (target, prop, value) &#123; return Reflect.set(target, prop, value) &#125;, // 拦截删除属性 deleteProperty (target, prop) &#123; return Reflect.deleteProperty(target, prop) &#125;&#125;)proxy.name = &#x27;tom&#x27; 5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 7.计算属性与监视 1.computed函数 与Vue2.x中computed配置功能一致 写法 1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123; ... //计算属性——简写 let fullName = computed(()=&gt;&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;) //计算属性——完整 let fullName = computed(&#123; get()&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;, set(value)&#123; const nameArr = value.split(&#x27;-&#x27;) person.firstName = nameArr[0] person.lastName = nameArr[1] &#125; &#125;)&#125; 2.watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 1234567891011121314151617181920212223242526272829303132//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123; const x1 = sum.value const x2 = person.age console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;) 8.生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate===&gt;setup() created=======&gt;setup() beforeMount ===&gt;onBeforeMount mounted=======&gt;onMounted beforeUpdate===&gt;onBeforeUpdate updated =======&gt;onUpdated beforeUnmount ==&gt;onBeforeUnmount unmounted =====&gt;onUnmounted 9.自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 10.toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,'name') 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 三、其它 Composition API 1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt; &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; import &#123;ref,customRef&#125; from &#x27;vue&#x27; export default &#123; name:&#x27;Demo&#x27;, setup()&#123; // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay)&#123; let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; track() //告诉Vue这个value值是需要被“追踪”的 return value &#125;, set(newValue)&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; value = newValue trigger() //告诉Vue去更新界面 &#125;,delay) &#125; &#125; &#125;) &#125; let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref return &#123; keyword &#125; &#125; &#125;&lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： 123456setup()&#123; ...... let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;) provide(&#x27;car&#x27;,car) ......&#125; 后代组件中： 123456setup(props,context)&#123; ...... const car = inject(&#x27;car&#x27;) return &#123;car&#125; ......&#125; 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 四、Composition API 的优势 1.Options API 存在的问题 使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势 我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件 1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 12345678&lt;teleport to=&quot;移动位置&quot;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;)) 使用Suspense包裹组件，并配置好default 与 fallback 12345678910111213&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt; 六、其他 1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123; data: () =&gt; (&#123; count: 0 &#125;), template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123; inserted: el =&gt; el.focus()&#125; Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 12345678.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; Vue3.x写法 123456789.v-enter-from,.v-leave-to &#123; opacity: 0;&#125;.v-leave-from,.v-enter-to &#123; opacity: 1;&#125; 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 1234&lt;my-component v-on:close=&quot;handleComponentEvent&quot; v-on:click=&quot;handleNativeClickEvent&quot;/&gt; 子组件中声明自定义事件 12345&lt;script&gt; export default &#123; emits: [&#x27;close&#x27;] &#125;&lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 …","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/tags/Vue3/"}],"author":"Li Jihong"},{"title":"L1-018 大笨钟","slug":"L1-018-大笨钟","date":"2022-09-19T02:24:00.000Z","updated":"2022-09-19T03:50:25.039Z","comments":true,"path":"2022/09/19/L1-018-大笨钟/","link":"","permalink":"http://example.com/2022/09/19/L1-018-%E5%A4%A7%E7%AC%A8%E9%92%9F/","excerpt":"PTA-天梯赛——L1-018 大笨钟 微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。 下面就请你写个程序，根据当前时间替大笨钟敲钟。 输入格式： 输入第一行按照hh:mm的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。 输出格式： 根据当前时间替大笨钟敲钟，即在一行中输出相应数量个Dang。如果不是敲钟期，则输出： 1Only hh:mm. Too early to Dang. 其中hh:mm是输入的时间。","text":"PTA-天梯赛——L1-018 大笨钟 微博上有个自称“大笨钟V”的家伙，每天敲钟催促码农们爱惜身体早点睡觉。不过由于笨钟自己作息也不是很规律，所以敲钟并不定时。一般敲钟的点数是根据敲钟时间而定的，如果正好在某个整点敲，那么“当”数就等于那个整点数；如果过了整点，就敲下一个整点数。另外，虽然一天有24小时，钟却是只在后半天敲1~12下。例如在23:00敲钟，就是“当当当当当当当当当当当”，而到了23:01就会是“当当当当当当当当当当当当”。在午夜00:00到中午12:00期间（端点时间包括在内），笨钟是不敲的。 下面就请你写个程序，根据当前时间替大笨钟敲钟。 输入格式： 输入第一行按照hh:mm的格式给出当前时间。其中hh是小时，在00到23之间；mm是分钟，在00到59之间。 输出格式： 根据当前时间替大笨钟敲钟，即在一行中输出相应数量个Dang。如果不是敲钟期，则输出： 1Only hh:mm. Too early to Dang. 其中hh:mm是输入的时间。 输入样例1： 119:05 输出样例1： 1DangDangDangDangDangDangDangDang 输入样例2： 107:05 输出样例2： 1Only 07:05. Too early to Dang. 我的解法（十分通俗易懂） 12345678910111213141516171819202122232425 #include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int hh,mm; scanf(&quot;%d:%d&quot;,&amp;hh,&amp;mm); if(hh&lt;12||(hh==12&amp;&amp;mm==0))//小于12时或者恰好等于12时都是不dang &#123; printf(&quot;Only %02d:%02d. Too early to Dang.&quot;,hh,mm); &#125; else &#123; int n=hh-12; if(mm&gt;0) &#123; n++; &#125; for(int i=0;i&lt;n;i++) &#123; printf(&quot;Dang&quot;); &#125; &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"L1-017 到底有多二","slug":"L1-017-到底有多二","date":"2022-09-19T01:13:00.000Z","updated":"2022-09-19T12:00:22.520Z","comments":true,"path":"2022/09/19/L1-017-到底有多二/","link":"","permalink":"http://example.com/2022/09/19/L1-017-%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E4%BA%8C/","excerpt":"PTA-天梯赛——L1-017 到底有多二 一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字-13142223336是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。 输入格式： 输入第一行给出一个不超过50位的整数N。 输出格式： 在一行中输出N犯二的程度，保留小数点后两位。","text":"PTA-天梯赛——L1-017 到底有多二 一个整数“犯二的程度”定义为该数字中包含2的个数与其位数的比值。如果这个数是负数，则程度增加0.5倍；如果还是个偶数，则再增加1倍。例如数字-13142223336是个11位数，其中有3个2，并且是负数，也是偶数，则它的犯二程度计算为：3/11×1.5×2×100%，约为81.82%。本题就请你计算一个给定整数到底有多二。 输入格式： 输入第一行给出一个不超过50位的整数N。 输出格式： 在一行中输出N犯二的程度，保留小数点后两位。 输入样例： 1-13142223336 输出样例： 181.82% 鸣谢安阳师范学院段晓云老师和软件工程五班李富龙同学补充测试数据！ 我的解法（十分通俗易懂） 12345678910111213141516171819202122232425262728293031323334353637 #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;stdio.h&gt; using namespace std; int main() &#123; string number; cin&gt;&gt;number; int c; double sum; c=number.length(); int i,k=0,len; if(number[0]==&#x27;-&#x27;)&#123; len=c-1; &#125; else &#123; len=c; &#125; for(i=0;i&lt;c;i++)&#123; if(number[i]==&#x27;2&#x27;)k=k+1; &#125; if(number[c-1]%2==0&amp;&amp;number[0]==&#x27;-&#x27;)&#123; sum=(double)k/(double)len*1.5*2*100; &#125; else if(number[c-1]%2==0)&#123; sum=(double)k/(double)len*2*100; &#125; else if(number[0]==&#x27;-&#x27;)&#123; sum=(double)k/(double)len*1.5*100; &#125; else &#123; sum=(double)k/(double)len*100; &#125; printf(&quot;%.2f&quot;,sum); cout&lt;&lt;&quot;%&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"我写了一首诗","slug":"我写了一首诗","date":"2022-09-12T13:34:00.000Z","updated":"2022-09-12T14:14:09.146Z","comments":true,"path":"2022/09/12/我写了一首诗/","link":"","permalink":"http://example.com/2022/09/12/%E6%88%91%E5%86%99%E4%BA%86%E4%B8%80%E9%A6%96%E8%AF%97/","excerpt":"","text":"没有大结局的故事值得品味吗?","categories":[{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Li Jihong"},{"title":"如果再来一次,,,,,,,,,,,,,哪有如果啊","slug":"日常感悟","date":"2022-09-11T08:21:00.000Z","updated":"2022-09-12T13:33:32.947Z","comments":true,"path":"2022/09/11/日常感悟/","link":"","permalink":"http://example.com/2022/09/11/%E6%97%A5%E5%B8%B8%E6%84%9F%E6%82%9F/","excerpt":"音乐真的可以表达心情，睡不着的每个夜全靠以前的每个律动进行催眠 如果再来一次，我可能会选择不遇见你。 如果再来一次，我可能尽量不和你接触，不说话，平平淡淡的相逢可能也会比现在的结局好看。 如果再来一次，我可能变得开朗，至少不像现在那么迷茫。 如果再来一次，我可能会选择远远观赏，而不是放大缺点，人的成长总是悄无声息的，而我却失去了耐心去等待。","text":"音乐真的可以表达心情，睡不着的每个夜全靠以前的每个律动进行催眠 如果再来一次，我可能会选择不遇见你。 如果再来一次，我可能尽量不和你接触，不说话，平平淡淡的相逢可能也会比现在的结局好看。 如果再来一次，我可能变得开朗，至少不像现在那么迷茫。 如果再来一次，我可能会选择远远观赏，而不是放大缺点，人的成长总是悄无声息的，而我却失去了耐心去等待。 如果再来一次，我可能会选择遵从内心，不想活的那么累。 如果再来一次，我可能选择珍惜，珍惜每天转头就能看到你的日子。 如果再来一次，我可能会更多点耐心，多点温柔。 如果再来一次，我可能会活成自己想要的样子。 如果再来一次，我可能选择。。。。。。。。。。。。。。。。。可是没有如果啊。。。。。 人活着的意义到底是什么？ 什么叫做热爱生活？ 怎么才叫成功？ 怎样才叫爱上一个人？ 为什么相爱的人不能在一起？ 什么叫所爱隔山海？ 什么叫爱情？ 赢了世界又如何？ 《当》： 当山峰没有棱角的时候 当河水不再流 当时间停住日夜不分 当天地万物化为虚有 我还是不能和你分手 不能和你分手 你的温柔是我今生最大的守候 当太阳不再上升的时候 当地球不再转动 当春夏秋冬不再变换 当花草树木全部凋残 我还是不能和你分散 不能和你分散 你的笑容是我今生最大的眷恋 让我们红尘作伴活得潇潇洒洒 策马奔腾共享人世繁华 对酒当歌唱出心中喜悦 轰轰烈烈把握青春年华 让我们红尘作伴活得潇潇洒洒 策马奔腾共享人世繁华 对酒当歌唱出心中喜悦 轰轰烈烈把握青春年华 《明天过后》：（我的闹钟） 没有星星的夜空 没有话题能补充 太多承诺从指缝中溜走 不敢奢求什么 回忆将我们扣留 一瞬间亲吻的时候 一切就好像轮回般朦胧 心动渐渐的失控 是否两个人足够捕捉爱的镜头 闭上了眼睛记得你的笑容 幸福的从容将灵魂都掏空 享受一分钟的感动 是否爱上一个人不问明天过后 山明和水秀不比你有看头 牵着你的手一直走到最后 这一刻怎么回头 《后悔无期》： 合：你若离去 后会无期 你若离去 后会无期 你若离去 后会无期 徐：等不到 风中你的脸颊 眼泪都美到很融洽 等不到 掩饰的雨落下 我的眼泪被你觉察 汪：等不到 你的雪月风花 我们的爱也有时差 等不到 不经意的牵挂 却没出息的放不下 徐：你说陪我到某年某月某天 却把我丢在某日某夜某街 错的并不是你 而是全世界 汪：你带走我的思念 却没说抱歉 一起走过的黑夜 变一地白雪 合：我把记忆都翻遍 却没有发现 我们约好的明天 你留给昨天 你若离去 后会无期 你若离去 后会无期 你若离去 后会无期 汪：等不到 手中松开的沙 被风扬起的很优雅 等不到 送你蝴蝶发卡 你的他爱上了短发 徐：你说陪我到某年某月某天 却把我丢在某日某夜某街 错的并不是你 而是全世界 合：你带走我的思念 却没说抱歉 一起走过的黑夜 变一地白雪 我把记忆都翻遍 却没有发现 我们约好的明天 你留给昨天 你带走我的思念 却没说抱歉 一起走过的黑夜 变一地白雪 我把记忆都翻遍 却没有发现 我们约好的明天 你留给昨天 汪：我们约好的明天 合：你留给昨天 夜空中最亮的星 夜空中最亮的星 能否听清 那仰望的人 心底的孤独和叹息 oh 夜空中最亮的星 能否记起 曾与我同行 消失在风里的身影 我祈祷拥有一颗透明的心灵 和会流泪的眼睛 给我再去相信的勇气 oh越过谎言去拥抱你 每当我找不到存在的意义 每当我迷失在黑夜里 oh~夜空中最亮的星 请指引我靠近你 夜空中最亮的星 是否知道 曾与我同行的身影 如今在哪里 oh夜空中最亮的星 是否在意 是等太阳升起 还是意外先来临 我宁愿所有痛苦都留在心里 也不愿忘记你的眼睛 给我再去相信的勇气 oh越过谎言去拥抱你 每当我找不到存在的意义 每当我迷失在黑夜里 oh~夜空中最亮的星 oh请照亮我前行 我祈祷拥有一颗透明的心灵 和会流泪的眼睛 给我再去相信的勇气 oh越过谎言去拥抱你 每当我找不到存在的意义 每当我迷失在黑夜里 oh~夜空中最亮的星 请照亮我前行 夜空中最亮的星 能否听清 那仰望的人 心底的孤独和叹息","categories":[{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Li Jihong"},{"title":"深度学习之——卷积神经网络","slug":"度学习之——卷积神经网络","date":"2022-09-11T03:40:00.000Z","updated":"2022-09-11T06:02:11.167Z","comments":true,"path":"2022/09/11/度学习之——卷积神经网络/","link":"","permalink":"http://example.com/2022/09/11/%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","excerpt":"背景 > 是否可能进─步减少训练参数数量? > 办法:提取出图像中的关键信息(轮廓)，再建立MLP模型进行训练 图像卷积运算 对图像矩阵与滤波器矩阵进行对应相乘再求和运算，转化得到新的矩阵,作用:快速定位图像中某些边缘特征 英文: convolution —&gt; CNN A与B的卷积通常表示为: A * B或convolution(A,B)","text":"背景 > 是否可能进─步减少训练参数数量? > 办法:提取出图像中的关键信息(轮廓)，再建立MLP模型进行训练 图像卷积运算 对图像矩阵与滤波器矩阵进行对应相乘再求和运算，转化得到新的矩阵,作用:快速定位图像中某些边缘特征 英文: convolution —&gt; CNN A与B的卷积通常表示为: A * B或convolution(A,B) 寻找竖向轮廓 > 结论：包含竖向轮廓的区域非常亮（灰度值高) ###### 寻找竖向轮廓 结论：将图片与轮廓滤波器进行卷积运算,可快速定位固定轮廓特征的位置 > 结论：一个过滤器不够，需要寻找很多过滤器 池化层实现维度缩减 池化:按照一个固定规则对图像矩阵进行处理,将其转换为更低维度的矩阵 最大法池化(Max-pooling)（常用） 保留核心信息的情况下，实现维度缩减 平均法池化(Avg-pooling)（取平均值） 卷积神经网络 把卷积、池化、mlp先后连接在一起，组成卷积神经网络。 ###### 卷积神经网络两大特点 参数共享(parameter sharing): 同一个特征过滤器可用于整张图片 稀疏连接（sparsity of connections): 生成的特征图片每个节点只与原图片中特定节点连接 =&gt; 将特征区域化，减小误差 卷积运算导致的两个问题 图像被压缩，造成信息丢失 边缘信息使用少，容易被忽略 通过padding增加像素的数量，由过滤器尺stride决定 ###### 有效解决方法：图像填充（padding） 通过在图像各边增加像素，使其在进行卷积运算维持原图大小 通过padding增加像素的数量，由过滤器尺stride决定 经典的CNN模型 LeNet-5 AlexNet VGG 参考经典的CNN结构搭建新模型 使用经典的CNN模型结构对图像预处理，再建立MLP模型 LeNet-5 1http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf AlexNet AlexNet论文： 1https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf 输入图像: 227X 227X 3RGB图，3个通道 训练参数:约60,000,000个 特点: 1、适用于识别较为复杂的彩色图，可识别1000种类别 2、结构比LeNet更为复杂，使用Relu作为激活函数 AlexNet的出现使得： 学术界开始相信深度学习技术, 在计算机视觉立用中可以得到很不错的结果。 VGG-16 VGG-16论文： 1https://arxiv.org/pdf/1409.1556.pdf 输入图像:227 X 227X 3 RGB图，3个通道 训练参数:约138,000,000个 特点: 1、所有卷积层tilter 宽和高都是3、步长为1，padding都使用same convolution; 2、所有池化层的 filtey宽和高都是况，步长都是2; 3、相比alexnet，有更多的filter用于提取轮廓信息，具有更高精准性","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://example.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-016 查验身份证","slug":"PTA-天梯赛——L1-016-查验身份证","date":"2022-09-08T13:51:00.000Z","updated":"2022-09-08T13:57:34.874Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-016-查验身份证/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-016-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/","excerpt":"PTA-天梯赛——L1-016 查验身份证 一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式： 输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式： 按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。","text":"PTA-天梯赛——L1-016 查验身份证 一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式： 输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式： 按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1： 12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1： 12312010X19890101123411010819671130186637070419881216001X 输入样例2： 1232320124198808240056110108196711301862 输出样例2： 1All passed C++高级解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;map&gt; using namespace std; int main() &#123; map&lt;int, char&gt; m; m.insert(pair&lt;int, char&gt;(0, &#x27;1&#x27;)); m.insert(pair&lt;int, char&gt;(1, &#x27;0&#x27;)); m.insert(pair&lt;int, char&gt;(2, &#x27;X&#x27;)); m.insert(pair&lt;int, char&gt;(3, &#x27;9&#x27;)); m.insert(pair&lt;int, char&gt;(4, &#x27;8&#x27;)); m.insert(pair&lt;int, char&gt;(5, &#x27;7&#x27;)); m.insert(pair&lt;int, char&gt;(6, &#x27;6&#x27;)); m.insert(pair&lt;int, char&gt;(7, &#x27;5&#x27;)); m.insert(pair&lt;int, char&gt;(8, &#x27;4&#x27;)); m.insert(pair&lt;int, char&gt;(9, &#x27;3&#x27;)); m.insert(pair&lt;int, char&gt;(10, &#x27;2&#x27;)); int n; string num[100]; int quan[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;; int count=0; cin&gt;&gt;n; for (int i = 0; i &lt; n; ++i) &#123; cin&gt;&gt;num[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; int sum=0; for (int j = 0; j &lt; num[i].size()-1; ++j) &#123; sum+=quan[j]*(num[i][j]-48);//48为字符&#x27;0&#x27;的十进制数 &#125; int Z=sum%11; char M=m[Z]; if (M==num[i][17])&#123; count++; &#125;else&#123; cout&lt;&lt;num[i]&lt;&lt;endl; &#125; &#125; if (count==n)&#123; cout&lt;&lt;&quot;All passed&quot;&lt;&lt;endl; &#125;&#125; C++一般解法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;/*三个变量分别储存权重、对应值、输入的身份证号*/int quanzhong[17]=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;int m[11]=&#123;1,0,10,9,8,7,6,5,4,3,2&#125;; //这里把X转化为10，方便之后的操作 string s;/*用来判断身份证号是否正确*/bool isTrue()&#123; int sum=0; for(int i=0;i&lt;17;i++)&#123; if(s[i]&lt;&#x27;0&#x27; || s[i]&gt;&#x27;9&#x27;)&#123; //先判断输入的值是否合法，如果不合法直接返回false return false; &#125;else&#123; sum += (s[i]-&#x27;0&#x27;)*quanzhong[i]; //用sum来保存每一位与权重相乘的和 &#125; &#125; int temp = (s[17]==&#x27;X&#x27;)?10:(s[17]-&#x27;0&#x27;); //如果最后一位是X的话就转化为10，其他不变 return (m[sum%11] == temp); //返回的值就是校验值与身份证最后一位是否相同 &#125;int main()&#123; int n,flag=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; if(!isTrue())&#123; //如果校验没有通过就把这个身份证输出，并把flag置1 cout&lt;&lt;s&lt;&lt;endl; flag = 1; &#125; &#125; if(flag == 0)&#123; //如果flag为0的话说明所有输入的身份证都通过校验 cout&lt;&lt;&quot;All passed&quot;; &#125; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"早知道暑假不留校了","slug":"早知道暑假不留校了","date":"2022-09-08T13:51:00.000Z","updated":"2022-09-08T16:57:12.591Z","comments":true,"path":"2022/09/08/早知道暑假不留校了/","link":"","permalink":"http://example.com/2022/09/08/%E6%97%A9%E7%9F%A5%E9%81%93%E6%9A%91%E5%81%87%E4%B8%8D%E7%95%99%E6%A0%A1%E4%BA%86/","excerpt":"","text":"","categories":[{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-015 跟奥巴马一起画方块","slug":"PTA-天梯赛——L1-015-跟奥巴马一起画方块","date":"2022-09-08T13:16:00.000Z","updated":"2022-09-08T13:23:00.048Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-015-跟奥巴马一起画方块/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-015-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%94%BB%E6%96%B9%E5%9D%97/","excerpt":"PTA-天梯赛——L1-015 跟奥巴马一起画方块 美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： 输入在一行中给出正方形边长N（3≤N≤21）和组成正方形边的某种字符C，间隔一个空格。 输出格式： 输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。 输入样例： 110 a 输出样例： 12345aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","text":"PTA-天梯赛——L1-015 跟奥巴马一起画方块 美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： 输入在一行中给出正方形边长N（3≤N≤21）和组成正方形边的某种字符C，间隔一个空格。 输出格式： 输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。 输入样例： 110 a 输出样例： 12345aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 我的解法 简单又容易理解，但一看就很low 123456789101112131415161718#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int N; string x; cin&gt;&gt;N; cin&gt;&gt;x; for(int i=0; i&lt;((N-1)/2)+1; i++) &#123; for(int j=0; j&lt;N; j++) &#123; cout&lt;&lt;x[0]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 网上的思路——Java 123456789101112131415161718192021222324252627282930import java.util.Scanner;/** * * @author 李季鸿 * */public class Main &#123; public static void main(String[] args) &#123; Scanner s=new Scanner(System.in);// int n=s.nextInt();// char ch1=s. String str = s.nextLine(); String[] ch=str.split(&quot; &quot;); int n=Integer.parseInt(ch[0]); int b=0; if(n%2==0) &#123; b=n/2; &#125;else &#123; b=(int)(n/2)+1; &#125;// System.out.println(b); for(int i=0;i&lt;b;i++) &#123; for(int j=0;j&lt;n-1;j++) &#123; System.out.print(ch[1]); &#125; System.out.println(ch[1]); &#125; &#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"}],"tags":[{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-013 计算阶乘和","slug":"PTA-天梯赛——L1-013-计算阶乘和","date":"2022-09-08T12:28:00.000Z","updated":"2022-09-08T12:40:32.253Z","comments":true,"path":"2022/09/08/PTA-天梯赛——L1-013-计算阶乘和/","link":"","permalink":"http://example.com/2022/09/08/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-013-%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98%E5%92%8C/","excerpt":"PTA-天梯赛——L1-013 计算阶乘和 对于给定的正整数N，需要你计算 S=1!+2!+3!+…+N!。 输入格式： 输入在一行中给出一个不超过10的正整数N。 输出格式： 在一行中输出S的值。 输入样例： 13 输出样例： 19","text":"PTA-天梯赛——L1-013 计算阶乘和 对于给定的正整数N，需要你计算 S=1!+2!+3!+…+N!。 输入格式： 输入在一行中给出一个不超过10的正整数N。 输出格式： 在一行中输出S的值。 输入样例： 13 输出样例： 19 我的解法 简单又容易理解，但一看就很low 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int JieCheng(int x)&#123; if(x&gt;0)&#123; return x*(JieCheng(x-1)); &#125; else&#123; return 1; &#125;&#125;int main() &#123; int N; int SUM = 0; cin&gt;&gt;N; for(int i=N; i&gt;0; i--) &#123; SUM+=JieCheng(i); &#125; cout&lt;&lt;SUM; return 0;&#125; 网上的思路 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int sum=0; for(int i=1;i&lt;=n;i++) &#123; int temp=1; for(int j=1;j&lt;=i;j++) &#123; temp=temp*j; &#125; sum=sum+temp; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"C++ STL库中map的常见操作","slug":"C-STL库中map的常见操作","date":"2022-09-08T06:42:00.000Z","updated":"2022-09-08T08:01:41.931Z","comments":true,"path":"2022/09/08/C-STL库中map的常见操作/","link":"","permalink":"http://example.com/2022/09/08/C-STL%E5%BA%93%E4%B8%ADmap%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","excerpt":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了","text":"头文件： 123#include &lt;iostream&gt;#include &lt;map&gt;using namespace std; 定义： 123map&lt;char,int&gt;m;//char是下面中括号中元素的数据类型（当然可以换成其他的），//int是等号右边的元素的数据类型。定义什么样的类型是随便的，现在听着可能有点迷，看了下面的赋值可能就懂了 123456789101112//对m进行赋值map&lt;char,int&gt;m;m[&#x27;a&#x27;]=4;m[&#x27;d&#x27;]=1;m[&#x27;c&#x27;]=2;//还是对m进行赋值map&lt;int,int&gt;m;m[1]=6;m[3]=4;m[2]=8;//这些数值均没有任何特殊意义，都是随便赋的值 常用函数 1234567891011121314m.push();m.pop(); //emmmmmm,上面这两个函数在map里面都没有m.clear(); //清空m中的所有元素m.empty(); //判断m是否为空m.begin(); //返回指向map头部的迭代器m.end(); //返回指向map尾部的迭代器m.rbegin(); //返回一个指向map尾部的逆向迭代器m.rend(); //返回一个指向map头部的逆向迭代器m.erase(); //删除指定元素m.inser(); //插入元素m.find(); //查找指定元素m.swap(); //交换两个map中的所有元素（注意：两个map中定义的类型需要完全一致） 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 提前说明： 其实在map内部，已经默认将其中的元素按照中括号中的元素的大小，按照从小到大的顺序排列好了 示例 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt;m1; map&lt;char,int&gt;m2; m1[&#x27;q&#x27;] = 1; m1[&#x27;w&#x27;] = 2; m1[&#x27;e&#x27;] = 3; m2[&#x27;a&#x27;] = 4; m2[&#x27;s&#x27;] = 5; m2[&#x27;d&#x27;] = 6; cout&lt;&lt;m1.size()&lt;&lt;endl;//运算结果：3 m1.erase(m1.begin());//删除m1中的第一个元素（指的是中括号中所有元素中最小的，即m1[&#x27;e&#x27;] = 3） map&lt;char,int&gt;::iterator it;//使用迭代器将map中的元素输出 for(it=m1.begin();it!=m1.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;it-&gt;second&lt;&lt;endl;//该语句等价于 cout&lt;&lt;(*it).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*it).second&lt;&lt;endl; //这是map的固定输出格式 &#125; //运算结果：q 1 // w 2 m1.swap(m2);//交换两个map中的所有元素 map&lt;char,int&gt;::reverse_iterator rit; for(rit=m1.rbegin();rit!=m1.rend();rit++)//逆向输出，可以看成从大到小输出 &#123; cout&lt;&lt;(*rit).first&lt;&lt;&#x27; &#x27;&lt;&lt;(*rit).second&lt;&lt;endl; &#125; //运算结果：s 5 // d 5 // a 4return 0;&#125; 下面是整个代码的运算结果：","categories":[{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}],"author":"Li Jihong"},{"title":"PTA-天梯赛——L1-011 A-B","slug":"PTA-天梯赛——L1-011-A-B","date":"2022-09-07T13:40:00.000Z","updated":"2022-09-08T00:09:27.887Z","comments":true,"path":"2022/09/07/PTA-天梯赛——L1-011-A-B/","link":"","permalink":"http://example.com/2022/09/07/PTA-%E5%A4%A9%E6%A2%AF%E8%B5%9B%E2%80%94%E2%80%94L1-011-A-B/","excerpt":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm!","text":"PTA-天梯赛——L1-011 A-B 本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。 输入格式： 输入在2行中先后给出字符串A和B。两字符串的长度都不超过10e4 ，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。 输出格式： 在一行中打印出A−B的结果字符串。 输入样例： 12I love GPLT! It&#x27;s a fun game!aeiou 输出样例： 1I lv GPLT! It&#x27;s fn gm! AC【map】 简单又容易理解，但是我不会想到的啊！！！ 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); map&lt;char,int&gt; m; for(int i=0; i&lt;b.length(); i++) &#123; m[b[i]]=1; &#125; for(int i=0; i&lt;a.length(); i++) &#123; if(m[a[i]]!=1) &#123; cout&lt;&lt;a[i]; &#125; &#125; return 0;&#125; 【set】 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; s; for(int i=0; i&lt;s2.length(); i++) &#123; s.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; if(s.find(s1[i])==s.end()) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string s1,s2; getline(cin,s1); getline(cin,s2); set&lt;char&gt; b; //cout&lt;&lt;s1&lt;&lt;endl&lt;&lt;s2&lt;&lt;endl; for(int i=0; i&lt;s2.length(); i++) &#123; b.insert(s2[i]); &#125; for(int i=0; i&lt;s1.length(); i++) &#123; set&lt;char&gt;::iterator it=b.find(s1[i]); if(*it!=s1[i]) cout&lt;&lt;s1[i]; &#125; return 0;&#125; 普通方法1 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b,c=&quot;&quot;; getline(cin,a); getline(cin,b); for(int i=0; i&lt;a.length(); i++) &#123; bool f=0; for(int j=0; j&lt;b.length(); j++) &#123; if(a[i]==b[j]) f=1; &#125; if(f==0) c=c+a[i]; &#125; cout&lt;&lt;c; return 0;&#125; 普通方法2 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a,b; getline(cin,a); getline(cin,b); int len=a.length(); for(int i=0; i&lt;b.length(); i++) &#123; char s=b[i]; for(int j=0; j&lt;len; j++) &#123; if(s==a[j]) &#123; for(int k=j; k&lt;len-1; k++) &#123; a[k]=a[k+1]; &#125; len--; j--;//这里要-- 就是排除连着两个一样的字符 &#125; &#125; &#125; for(int i=0; i&lt;len; i++) cout&lt;&lt;a[i]; return 0;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"}],"author":"Li Jihong"},{"title":"前端笔记","slug":"前端笔记","date":"2022-09-06T04:00:00.000Z","updated":"2022-09-08T02:08:44.047Z","comments":true,"path":"2022/09/06/前端笔记/","link":"","permalink":"http://example.com/2022/09/06/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/","excerpt":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt;","text":"前端笔记 字体图标-Iconfont 引用字体图标样式表 1&lt;link rel=&quot;stylesheet&quot; href=&quot;./iconfont.css&quot;&gt; 调用图标对应的类名，必须调用两个类名 iconfont类：基本样式，包含字体的使用等 icon-xxx:图标对应的类名 表格隔行换色: 123456789101112131415161718192021222324252627&lt;style&gt; .bg &#123; background-color: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 用到新的鼠标事件鼠标经过onmouseover鼠标离开onmouseout核心思路∶鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色注意:第一行( thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行 --&gt; &lt;script&gt; // 1.获取元素 获取的是 tbody里面的所有行 var trs = document.querySelector(&#x27;tbody&#x27;).querySelector(&#x27;tr&#x27;); // 2.利用循环绑定注册事件 for(var i=0;i&lt;trs.length;i++)&#123; // 3.鼠标经过事件 onmouseover trs[i].onmouseover = function()&#123; // console.log(11); this.className = &#x27;bg&#x27;; &#125; // 4.鼠标离开事件 onmouseout trs[i].onmouseout = function()&#123; // console.log(11); this.className = &#x27;&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 表单全选: 1234567891011121314151617181920212223242526&lt;body&gt; &lt;script&gt; var j_caAll = document.getElementById(&#x27;j_caAll&#x27;); //j_caAll是全局选项 var j_tbs = document.getElementById(&#x27;j_tbs&#x27;).getElementsByTagName(&#x27;input&#x27;); //下面所有的复选框 //注册事件 j_caAll.onclick = function()&#123; //this.checked 它可以得到当前复选框的选中状态，如果是true就是选中，如果是false就是未选中 for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].checked = this.checked; &#125; &#125; for(var i = 0; i &lt; j_tbs.length; i++)&#123; j_tbs[i].onclick = function()&#123; var flag = true; //控制全选按钮是否选中 //每次点击下面的复选框都要检查4个小按钮是否被选中 for(var i =0; i &lt; j_tbs.length; i++)&#123; if(!j_tbs[i].checked)&#123;//有一个按钮没有被选中 flag = false; break; //退出for循环，这样可以提高只要效率，因为只要有一个没被选中，就无需循环 &#125; &#125; j_caAll.checked = flag; &#125; &#125; &lt;/script&gt;&lt;/body&gt; Tab栏切换: 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;script&gt; var tab_list = document.querySelector(&#x27;.tab_list&#x27;); var lis = tab_list.querySelectorAll(&#x27;li&#x27;); var items = document.querySelectorAll(&#x27;.item&#x27;); //for循环绑定点击事件 for(var i = 0; i&lt; lis.length; i++)&#123; //开始给5个小li 设置索引号 lis[i].setAttribute(&#x27;index&#x27;, i); lis[i].onclick = function()&#123; //1.上的模块选项卡，点击某一个，当前这个底色会是红色，其余不变（排他思想）修改类名的方式 //获取元素 //干掉所有人 其余的li清除class 这个类 for(var i =0 ;i &lt; lis.length; i++)&#123; lis[i].className = &#x27;&#x27;; &#125; //留下我自己 this.className = &#x27;current&#x27;; //2.下面的显示内容模块 var index = this.getAttribute(&#x27;index&#x27;); console.log(index); //干掉所有人 让其余的item 这些div隐藏 for(var i = 0; i &lt; items.length; i++)&#123; items[i].style.display = &#x27;none&#x27;; &#125; //留下我自己 让对应的item 显示出来 items[index].style.display = &#x27;block&#x27;; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 下拉菜单: 1234567891011121314&lt;script&gt; //1. 获取元素 var nav = document.querySelector(&#x27;.nav&#x27;); var lis = nav.children; //得到四个小li //2. 循环注册事件 for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].onmouseover = function()&#123; this.children[1].style.display = &#x27;block&#x27;; &#125; lis[i].onmouseout = function()&#123; this.children[1].style.display = &#x27;none&#x27;; &#125; &#125; &lt;/script&gt; 简单留言板: 12345678910111213141516171819202122&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value; //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); &#125; &#125; &lt;/script&gt; 删除留言: 123456789101112131415161718192021222324252627282930&lt;script&gt; //1. 获取元素 var btn = document.querySelector(&#x27;button&#x27;); var text = document.querySelector(&#x27;textarea&#x27;); var ul = document.querySelector(&#x27;ul&#x27;); //2. 注册事件 btn.onclick = function()&#123; if(text.value == &#x27;&#x27;)&#123; alert(&#x27;您没有输入内容&#x27;); return false; &#125;else&#123; // console.log(text.value); //(1)创建元素 var li = document.createElement(&#x27;li&#x27;); //现有li 才能赋值 li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 //(2)添加元素 // ul.appendChild(li); ul.insertBefore(li,ul.children[0]); //(3)删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelector(&#x27;a&#x27;); for(var i=0; i&lt; as.length;i++)&#123; as[i].onclick = function()&#123; //node.removeChild(child); 删除的是li当前所在的li this.parentNode; ul.removeChild(this.parentNode); &#125; &#125; &#125; &#125; &lt;/script&gt; 动态生成表格： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!-- * @Author: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @Date: 2022-08-17 12:40:22 * @LastEditors: error: git config user.name &amp;&amp; git config user.email &amp; please set dead value or install git * @LastEditTime: 2022-08-17 14:20:42 * @FilePath: \\JS\\动态生成表格.html * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; table &#123; width: 500px; margin: 100px auto; border-collapse: collapse; text-align: center; &#125; td, th &#123; border: 1px solid #333; &#125; thead tr &#123; height: 40px; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table cellspacing=&quot;&#x27;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;科目&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //1.先去准备好学生的数据 var datas =[ &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;javascript&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;C++&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;java&#x27;, score:100 &#125;, &#123; name: &#x27;李季鸿&#x27;, subject: &#x27;linux&#x27;, score:100 &#125;, ]; //2. 往tbody里面创建行：有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector(&#x27;tbody&#x27;); for(var i = 0; i &lt; datas.length; i++)&#123;//外面的for循环管是行 tr //1.创建 tr 行 var tr = document.createElement(&#x27;tr&#x27;); tbody.appendChild(tr); //2.行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数 for循环遍历对象 for(var k in datas[i])&#123; //里卖弄的for循环管的是列 td //创建单元格 var td = document.createElement(&#x27;td&#x27;); //吧对象里面的属性值 datas[i][k] 给td // console.log(datas[i][k]); td.innerHTML = datas[i][k]; tr.appendChild(td); &#125; //3.创建有删除2个字的单元格 var td = document.createElement(&#x27;td&#x27;); td.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;;//javascript:;可以阻止链接跳转 tr.appendChild(td); &#125; //4. 删除操作开始 var as = document.querySelectorAll(&#x27;a&#x27;); for(var i = 0; i &lt; as.length; i++)&#123; as[i].onclick = function()&#123; //点击a 删除当前a所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[],"author":"Li_Jihong"}],"categories":[{"name":"通知","slug":"通知","permalink":"http://example.com/categories/%E9%80%9A%E7%9F%A5/"},{"name":"算法模板","slug":"算法模板","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"},{"name":"李季鸿的日常随笔","slug":"李季鸿的日常随笔","permalink":"http://example.com/categories/%E6%9D%8E%E5%AD%A3%E9%B8%BF%E7%9A%84%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"},{"name":"代码库","slug":"代码库","permalink":"http://example.com/categories/%E4%BB%A3%E7%A0%81%E5%BA%93/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"刷题","slug":"C/刷题","permalink":"http://example.com/categories/C/%E5%88%B7%E9%A2%98/"},{"name":"PTA","slug":"刷题/PTA","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/PTA/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"人工智能","slug":"人工智能","permalink":"http://example.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"语法","slug":"语法","permalink":"http://example.com/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"更新","slug":"更新","permalink":"http://example.com/tags/%E6%9B%B4%E6%96%B0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"},{"name":"gitee","slug":"gitee","permalink":"http://example.com/tags/gitee/"},{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"PTA","slug":"PTA","permalink":"http://example.com/tags/PTA/"},{"name":"天体赛","slug":"天体赛","permalink":"http://example.com/tags/%E5%A4%A9%E4%BD%93%E8%B5%9B/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"天梯赛","slug":"天梯赛","permalink":"http://example.com/tags/%E5%A4%A9%E6%A2%AF%E8%B5%9B/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/tags/Vue3/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"map","slug":"map","permalink":"http://example.com/tags/map/"}]}